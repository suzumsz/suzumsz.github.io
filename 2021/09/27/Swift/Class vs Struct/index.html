<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Swift) Class와 Struct의 차이점에 대해 설명하시오. - suzumsz</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="suzumsz"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="suzumsz"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Class와 Struct 차이점Class 참조 타입(Reference Type) 상속 가능 heap memory 영역에 할당 (속도가 느림) 런타임에 직접 alloc하며 reference counting을 통해 dealloc이 필요 memory fragmentation 등의 overhead가 존재 NSData serialize 가능 Codable 사용 불가"><meta property="og:type" content="blog"><meta property="og:title" content="Swift) Class와 Struct의 차이점에 대해 설명하시오."><meta property="og:url" content="https://suzumsz.github.io/2021/09/27/Swift/Class%20vs%20Struct/"><meta property="og:site_name" content="suzumsz"><meta property="og:description" content="Class와 Struct 차이점Class 참조 타입(Reference Type) 상속 가능 heap memory 영역에 할당 (속도가 느림) 런타임에 직접 alloc하며 reference counting을 통해 dealloc이 필요 memory fragmentation 등의 overhead가 존재 NSData serialize 가능 Codable 사용 불가"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://suzumsz.github.io/img/og_image.png"><meta property="article:published_time" content="2021-09-26T15:00:00.000Z"><meta property="article:modified_time" content="2021-10-05T11:11:47.413Z"><meta property="article:author" content="Sujeong Kim"><meta property="article:tag" content="Swift"><meta property="article:tag" content="iOS"><meta property="article:tag" content="Class"><meta property="article:tag" content="Struct"><meta property="article:tag" content="Boostcourse"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://suzumsz.github.io/2021/09/27/Swift/Class%20vs%20Struct/"},"headline":"Swift) Class와 Struct의 차이점에 대해 설명하시오.","image":["https://suzumsz.github.io/img/og_image.png"],"datePublished":"2021-09-26T15:00:00.000Z","dateModified":"2021-10-05T11:11:47.413Z","author":{"@type":"Person","name":"Sujeong Kim"},"publisher":{"@type":"Organization","name":"suzumsz","logo":{"@type":"ImageObject","url":null}},"description":"Class와 Struct 차이점Class 참조 타입(Reference Type) 상속 가능 heap memory 영역에 할당 (속도가 느림) 런타임에 직접 alloc하며 reference counting을 통해 dealloc이 필요 memory fragmentation 등의 overhead가 존재 NSData serialize 가능 Codable 사용 불가"}</script><link rel="canonical" href="https://suzumsz.github.io/2021/09/27/Swift/Class%20vs%20Struct/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">suzumsz</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="카탈로그" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-09-26T15:00:00.000Z" title="2021. 9. 27. 오전 12:00:00">2021-09-27</time>&nbsp;게시 됨</span><span class="level-item"><time dateTime="2021-10-05T11:11:47.413Z" title="2021. 10. 5. 오후 8:11:47">2021-10-05</time>&nbsp;업데이트 됨</span><span class="level-item"><a class="link-muted" href="/categories/Swift/">Swift</a></span><span class="level-item">9분안에 읽기 (약 1289 단어)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>회 방문</span></div></div><h1 class="title is-3 is-size-4-mobile">Swift) Class와 Struct의 차이점에 대해 설명하시오.</h1><div class="content"><h2 id="Class와-Struct-차이점"><a href="#Class와-Struct-차이점" class="headerlink" title="Class와 Struct 차이점"></a>Class와 Struct 차이점</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li><code>참조 타입(Reference Type)</code></li>
<li><code>상속</code> 가능</li>
<li>heap memory 영역에 할당 (속도가 느림)</li>
<li>런타임에 직접 alloc하며 reference counting을 통해 dealloc이 필요</li>
<li>memory fragmentation 등의 overhead가 존재</li>
<li>NSData serialize 가능</li>
<li>Codable 사용 불가능</li>
<li>런타임에 타입 캐스팅을 통해서 클래스 인스턴스에 따라 여러 동작이 가능</li>
<li>deinitializer 존재</li>
</ul>
<h3 id="Struct-Enum"><a href="#Struct-Enum" class="headerlink" title="Struct / Enum"></a>Struct / Enum</h3><ul>
<li><code>값 타입(Value Type)</code></li>
<li><code>상속 불가능</code> (protocol은 사용 가능)</li>
<li>stack memory 영역에 할당 (속도가 빠름)</li>
<li>scope based lifetime: 컴파일타임에 compiler가 언제 메모리를 할당/해제할지 정확히 알고있음</li>
<li>data locality: CPU 캐시 히트율이 높음</li>
<li>NSData로 serialize 불가능</li>
<li>Codable 프로토콜을 이용하여 손쉬운 JSON &lt;-&gt; struct 변환 가능 (Swift 4 이상)</li>
<li>항상 새로운 변수로 copy가 일어나기 때문에 multi-thread 환경에서 공유변수로 인해 문제를 일으킬 확률이 적음 </li>
</ul>
<span id="more"></span>

<h2 id="참조-타입과-값-타입-비교"><a href="#참조-타입과-값-타입-비교" class="headerlink" title="참조 타입과 값 타입 비교"></a>참조 타입과 값 타입 비교</h2><h3 id="참조-타입-Reference-Type"><a href="#참조-타입-Reference-Type" class="headerlink" title="참조 타입(Reference Type)"></a>참조 타입(Reference Type)</h3><ul>
<li>데이터를 전달할 때 값의 <code>메모리 위치를 전달</code>한다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클래스 생성</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> property <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스 인스턴스 생성</span></span><br><span class="line"><span class="comment">// 첫 번째 참조 생성</span></span><br><span class="line"><span class="comment">// 두 개 다 같은 것이니까 아무거나 사용하삼 ~</span></span><br><span class="line"><span class="keyword">let</span> firstClassReference : <span class="type">ReferenceType</span> <span class="operator">=</span> <span class="type">ReferenceType</span>()</span><br><span class="line"><span class="comment">// let firstClassReference = ReferenceType()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 참조 변수에 첫 번째 참조 할당</span></span><br><span class="line"><span class="keyword">let</span> secondClassReference <span class="operator">=</span> firstClassReference</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;first class reference property : <span class="subst">\(firstClassReference.property)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// ----- 출력값</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;second class reference property : <span class="subst">\(secondClassReference.property)</span>&quot;</span>) </span><br><span class="line"><span class="comment">// ----- 출력값</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 참조를 통해 인스턴스의 프로퍼티 값 변경</span></span><br><span class="line">secondClassReference.property <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 클래스 참조는 첫 번째 클래스 인스턴스를 참조하기 때문에</span></span><br><span class="line"><span class="comment">// 두 번째 참조를 통해 인스턴스의 프로퍼티 값을 변경하면</span></span><br><span class="line"><span class="comment">// 첫 번째 클래스 인스턴스의 프로퍼티 값도 변경 됨</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;first class reference property : <span class="subst">\(firstClassReference.property)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// ----- 출력값</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;second class reference property : <span class="subst">\(secondClassReference.property)</span>&quot;</span>) </span><br><span class="line"><span class="comment">// ----- 출력값</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 상수로 선언했어도 값이 바뀌는 이유는 </span></span><br><span class="line"><span class="comment">// secondClassReference 자체를 변경한 것이 아닌 </span></span><br><span class="line"><span class="comment">// secondClassReference가 바라보는 값을 변경하는 것이기 때문에 가능하다.</span></span><br></pre></td></tr></table></figure>

<h3 id="값-타입-Value-Type"><a href="#값-타입-Value-Type" class="headerlink" title="값 타입(Value Type)"></a>값 타입(Value Type)</h3><ul>
<li>데이터를 전달할 때 <code>값을 복사하여 전달</code>한다.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 구조체 생성</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ValueType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> property <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 첫 번째 구조체 인스턴스</span></span><br><span class="line"><span class="keyword">let</span> firstStructInstance <span class="operator">=</span> <span class="type">ValueType</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번재 구조체 인스턴스에 첫 번째 인스턴스 값 복사</span></span><br><span class="line"><span class="keyword">let</span> secondStructInstance <span class="operator">=</span> firstStructInstance</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두번째 구조체 인스턴스 프로퍼티 값 수정</span></span><br><span class="line">secondStructInstance.property <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 번째 구조체 인스턴스는 첫 번째 구조체를 똑같이 복사한 </span></span><br><span class="line"><span class="comment">// 별도의 인스턴스이기 때문에 </span></span><br><span class="line"><span class="comment">// 두 번째 구조체 인스턴스의 프로퍼티 값을 변경해도</span></span><br><span class="line"><span class="comment">// 첫 번째 구조체 인스턴스의 프로퍼티 값에는 영향이 없음</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;first struct instance property : <span class="subst">\(firstStructInstance.property)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// ----- 출력값</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;second struct instance property : <span class="subst">\(secondStructInstance.property)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// ----- 출력값</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="값-타입-Value-Type-을-사용하는-경우"><a href="#값-타입-Value-Type-을-사용하는-경우" class="headerlink" title="값 타입(Value Type)을 사용하는 경우"></a>값 타입(Value Type)을 사용하는 경우</h2><ul>
<li>연관된 몇몇의 값들을 모아서 <code>하나의 데이터 타입으로 표현</code>하고 싶은 경우</li>
<li>다른 객체 또는 함수 등으로 전달될 때 참조가 아니라 <code>복사(값 복사) 할 경우</code></li>
<li>자신을 상속할 필요가 없거나, 다른 타입을 상속 받을 필요가 없는 경우</li>
</ul>
<h2 id="스위프트에서의-사용"><a href="#스위프트에서의-사용" class="headerlink" title="스위프트에서의 사용"></a>스위프트에서의 사용</h2><ul>
<li>스위프트의 <code>기본 데이터 타입</code>은 모두 <code>구조체</code>로 구현되어있다.</li>
<li>스위스트는 <code>구조체</code>와 <code>열거형</code> 사용을 <code>선호</code>한다.</li>
<li><code>Apple 프레임워크</code>는 대부분 <code>클래스를 사용</code>한다.</li>
<li>구조체/클래스 선택과 사용은 개발자의 몫이다.</li>
</ul>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>클래스는 참조 타입이고, 데이터를 전달할 때 값의 <code>메모리 위치를 전달</code>한다.</li>
<li>두 번째 클래스가 첫 번째 클래스 인스턴스를 참조하기 할 때, 두 번째 클래스의 인스턴스 프로퍼티 값을 변경하면 첫 번째 클래스 인스턴스의 프로퍼티 값도 변경된다.</li>
<li>구조체는 값 타입입고, 데이터를 전달할 때 <code>값을 복사하여 전달</code>한다.</li>
<li>두 번째 구조체 인스턴스가 첫 번째 구조체를 복사하면 그것은 똑같이 복사된 별도의 인스턴스이기 때문에 두 번째 구조체 인스턴스의 프로퍼티 값을 변경해도 첫 번째 구조체 인스턴스의 프로퍼티 값에는 영향이 없다.</li>
<li>class안에 struct 변수를 property로 정의하는것 가능하며, 반대로 struct의 property중 하나로 class 인스턴스 변수를 갖고있는 것도 가능하다. </li>
<li>이 경우 해당 struct 변수의 copy가 일어날때 class 인스턴스의 주소값만 복사된다.</li>
<li>우리가 사용하는 배열, 딕셔너리, 셋과 같은 컬렉션 타입은 <code>구조체로서 구현</code>되어 있다.</li>
</ul>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.boostcourse.org/mo122/lecture/11274?isDesc=false">부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 클래스 vs 구조체 / 열거형</a></li>
<li><a target="_blank" rel="noopener" href="https://www.letmecompile.com/swift-struct-vs-class-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EB%B9%84%EA%B5%90-%EB%B6%84%EC%84%9D/">Swift struct vs. class 차이점 비교 분석</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Swift) Class와 Struct의 차이점에 대해 설명하시오.</p><p><a href="https://suzumsz.github.io/2021/09/27/Swift/Class vs Struct/">https://suzumsz.github.io/2021/09/27/Swift/Class vs Struct/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Sujeong Kim</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-09-27</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-10-05</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Swift/">Swift</a><a class="link-muted mr-2" rel="tag" href="/tags/iOS/">iOS</a><a class="link-muted mr-2" rel="tag" href="/tags/Class/">Class</a><a class="link-muted mr-2" rel="tag" href="/tags/Struct/">Struct</a><a class="link-muted mr-2" rel="tag" href="/tags/Boostcourse/">Boostcourse</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/09/28/Architecture/MVC/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Architecture) MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/09/24/Swift/Class/"><span class="level-item">Swift) Class란?</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">댓글</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://suzumsz.github.io/2021/09/27/Swift/Class%20vs%20Struct/';
            this.page.identifier = '2021/09/27/Swift/Class vs Struct/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'suzumsz' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">카탈로그</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Class와-Struct-차이점"><span class="level-left"><span class="level-item">1</span><span class="level-item">Class와 Struct 차이점</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Class"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Class</span></span></a></li><li><a class="level is-mobile" href="#Struct-Enum"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Struct / Enum</span></span></a></li></ul></li><li><a class="level is-mobile" href="#참조-타입과-값-타입-비교"><span class="level-left"><span class="level-item">2</span><span class="level-item">참조 타입과 값 타입 비교</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#참조-타입-Reference-Type"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">참조 타입(Reference Type)</span></span></a></li><li><a class="level is-mobile" href="#값-타입-Value-Type"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">값 타입(Value Type)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#값-타입-Value-Type-을-사용하는-경우"><span class="level-left"><span class="level-item">3</span><span class="level-item">값 타입(Value Type)을 사용하는 경우</span></span></a></li><li><a class="level is-mobile" href="#스위프트에서의-사용"><span class="level-left"><span class="level-item">4</span><span class="level-item">스위프트에서의 사용</span></span></a></li><li><a class="level is-mobile" href="#정리"><span class="level-left"><span class="level-item">5</span><span class="level-item">정리</span></span></a></li><li><a class="level is-mobile" href="#참고"><span class="level-left"><span class="level-item">6</span><span class="level-item">참고</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">2월 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">10월 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">9월 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">3월 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">업데이트 소식 받기</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=undefined&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="구독"></div></div></form></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">suzumsz</a><p class="is-size-7"><span>&copy; 2022 Sujeong Kim</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv">0</span>명의 사용자가 방문 함</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="맨 위로" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "이 웹 사이트는 귀하의 경험을 향상시키기 위해 Cookie를 사용합니다.",
          dismiss: "무시",
          allow: "허용",
          deny: "거부",
          link: "더 알아보기",
          policy: "Cookie 정책",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(제목 없음)","posts":"포스트","pages":"페이지","categories":"카테고리","tags":"태그"});
        });</script></body></html>