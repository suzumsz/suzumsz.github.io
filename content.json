{"pages":[],"posts":[{"title":"Architecture) MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.","text":"MVC 패턴이란? Model(모델), View(뷰), Controller(컨트롤러) Traditional MVC 다이어그램을 보면 Model, View 그리고 Controller, 이 세 요소가 서로 강하게 연결되어 있음을 알 수 있다. Model에서는 애플리케이션에서 사용할 데이터들을 관리하고, View는 유저 인터페이스를 표현 및 관리한다. Controller는 View와 Model의 다리 역할을 해 View의 입력을 Model이 반영하고, Model의 변화를 View에 갱신하는 역할을 한다. 강하게 연결된 셋은 독립성이 낮기 때문에 이들 각각의 재사용성은 굉장히 떨어지며, 그렇기 때문에 현재 iOS 개발에는 전통적인 MVC 아키텍쳐는 맞지 않다고 볼 수 있다. Apple’s MVC 위의 이유로 애플에서는 새로운 MVC 아키텍쳐를 제시했다. 기존 MVC 패턴과는 다르다. Controller가 View와 Model의 중재자 역할을 함으로써 View와 Model에 독립성을 주었다. 하지만Controller의 역할을 수행하는 UIViewController의 이름에서도 알 수 있듯이,Controller가 View를 포함하는 것은 물론, View의 Life Cycle까지 관리하기 때문에 View와 Controller를 분리하기 어렵고, 재사용도 어렵다. 또한 테스트도 불가능하다.ViewController가 너무 많은 역할을 하기 때문에 MVC를 Massive View Controller라고 부르기도 한다. 그러므로 실제 다이어그램은 다음과 같은 흐름을 갖게 된다. View와 Controller가 강하게 연결되어 있어 View Controller가 거의 모든 일을 한다. 좋은 아키텍쳐의 기준에 얼마나 부합하는가?Distribution - Model과 View가 독립되었지만, View와 Controller가 너무 밀접하게 연관되어있기 때문에 독립성을 확보하지 못한다.Testability - View와 Controller가 강하게 연결되어 있기 때문에, 오로지 Model만 테스팅을 진행할 수 있다.Ease of use - 다른 패턴들에 비해 코드 길이가 적고, 친숙한 아키텍처이기 때문에 개발자들이 쉽게 유지보수 할 수 있다. Cocoa MVC 패턴은 개발 진행 속도에 있어서는 가장 빠르다고 할 수 있다. 따라서 아키텍처가 중요하지 않을 때는 선택할만한 패턴이지만, 나중에 유지보수가 어렵다는 문제가 있다. 참고 iOS 아키텍처 패턴(MVC, MVVM, VIPER) protocorn93 - iOS Architecture jiyeonlab - [iOS 아키텍처 패턴] MVC iOS Architecture Patterns","link":"/2021/09/28/Architecture/MVC/"},{"title":"Architecture) MVP 패턴이란?","text":"MVP 패턴이란? Model(모델), View(UIView/UIViewController), Presenter Model은 MVC 패턴에서 의미하는 모델과 같은 역할을 한다. 즉, 앱의 실행에 필요한 실질적인 데이터를 갖고 있다.View는 UIView와 UIViewController가 여기에 해당하며, 비즈니스 로직과 관련된 일은 모두 Presenter가 하도록 한다.Presenter는 UIKit과 관련이 없는 로직들을 수행하며, 사용자 응답에 반응하거나 UI를 업데이트하는 일을 한다.(비즈니스 로직 관련된 일 수행) 다이어그램 MVC 패턴과 굉장히 유사한 구조로 이루어져있지만, MVP는 UIView와 UIViewController가 View에 속해있다. (이로인해 MVC에서의 테스팅 한계를 어느정도 극복했다.) MVC에서 UIViewController는 Controller에 해당했고 그로인해 View와 강하게 연결되어 있었지만, MVP에서는 이 둘을 View로 분류하는 대신 Presenter라는 것이 등장한 것이다. Presenter는 View(UIView, UIViewController)의 Life Cycle에 영향을 받지 않고 레이아웃 코드 역시 Presenter에 존재하지 않는다. Controller의 역할답게 View를 데이터와 상태에 맞추어 갱신하는 역할을 갖게 된다. 즉, Presenter는 Model로 부터 갱신된 데이터를 받아와 뷰를 갱신하는 역할을 한다. 뷰를 갱신하기 위한 메소드를 직접 작성한다던지 각 이벤트에 따른 메소드들을 바인딩해줘야 하는 등의 이유로 개발 비용이 MVC보다는 높아진다. View는 Presenter를 소유하고 있어야 하며 Presenter는 유저 액션, 데이터 갱신, 상태 갱신에 따라 View를 갱신해주어야 한다.이를 코드로써 구현할 때 View는 Presenter를 강한 참조로 소유하고 있고 Presenter는 약한 참조로 View를 단순히 가리키고만 있는다.그렇기 때문에 View의 Life Cycle의 영향과 레이아웃 코드와 액션 코드가 공존하는 등의 의존성에서는 벗어날 수 있지만 참조에 의한 1:1 의존성에서는 벗어날 수 없다는 한계가 존재한다. 좋은 아키텍쳐의 기준에 얼마나 부합하는가? Distribution - 전통적인 MVC에서 발생한 Model과 View의 의존성 문제는 해결하였다. 참조에 의한 View와 Controller의 의존성은 존재하지만 비교적 셋 모두 역할별로 적절히 나누어져 있다고 말할 수 있다. Testability - 각각의 요소를 독립적으로 테스팅하기 용이하다. Easy of Use - Presenter의 추가와 이를 구현하기 위한 프로토콜등의 추가로 코드가 MVC보다 길어진다. 참고 protocorn93 - iOS Architecture jiyeonlab - [iOS 아키텍처 패턴] MVP 김종권의 iOS 앱 개발 알아가기 - MVC, MVP, MVVM 디자인 패턴","link":"/2021/09/29/Architecture/MVP/"},{"title":"Architecture) MVVM 패턴이란?","text":"MVVM 패턴이란? Model, View, ViewMode View는 오직 시각적인 요소(레이아웃, 애니매이션 그리고 UI 요소들에 대한 초기화 작업 코드들)로만 이루어져야 하고, View Controller가 View가 된다.ViewModel은 View의 각 UI 요소들에 대한 인터페이스를 제공하며, 중간 역할을 한다. 다이어그램 Controller를 빼고 ViewModel을 추가한 패턴이다. View의 UI 요소들과 ViewModel의 인터페이스를 연결시키는 작업을 Binding(바인딩-연결고리)이라고 한다. ViewModel은 Model에 변화를 주고, ViewModel을 업데이트하는데 이 때, 바인딩으로 인해 View도 업데이트 된다. 예를들어,Date를 String으로 변환하는 작업은 ViewModel에서 진행되고 View에서는 이에 맞춰 갱신만 일어나게 된다.그렇기 때문에 View가 어떻게 구성되어 있는지와 상관없이 View의 비즈니스 로직에 대해서 테스팅이 가능하며, 바인딩으로 인해 코드 양이 많이 줄어든다는 장점이 있다. MVVM에서 바인딩을 직접 작성하지 않으려면? KVO 기반 라이브러리를 사용하거나 Delegation Property Observer RxSwift같은 Reactive Programming을 사용해야한다. 이것이 MVVM하면 RxSwift를 주로 떠올리는 이유이다. 참고 iOS 아키텍처 패턴(MVC, MVVM, VIPER) protocorn93 - iOS Architecture","link":"/2021/09/30/Architecture/MVVM/"},{"title":"Swift) Class와 Struct의 차이점에 대해 설명하시오.","text":"Class와 Struct 차이점Class 참조 타입(Reference Type) 상속 가능 heap memory 영역에 할당 (속도가 느림) 런타임에 직접 alloc하며 reference counting을 통해 dealloc이 필요 memory fragmentation 등의 overhead가 존재 NSData serialize 가능 Codable 사용 불가능 런타임에 타입 캐스팅을 통해서 클래스 인스턴스에 따라 여러 동작이 가능 deinitializer 존재 Struct / Enum 값 타입(Value Type) 상속 불가능 (protocol은 사용 가능) stack memory 영역에 할당 (속도가 빠름) scope based lifetime: 컴파일타임에 compiler가 언제 메모리를 할당/해제할지 정확히 알고있음 data locality: CPU 캐시 히트율이 높음 NSData로 serialize 불가능 Codable 프로토콜을 이용하여 손쉬운 JSON &lt;-&gt; struct 변환 가능 (Swift 4 이상) 항상 새로운 변수로 copy가 일어나기 때문에 multi-thread 환경에서 공유변수로 인해 문제를 일으킬 확률이 적음 참조 타입과 값 타입 비교참조 타입(Reference Type) 데이터를 전달할 때 값의 메모리 위치를 전달한다. 1234567891011121314151617181920212223242526272829303132333435363738// 클래스 생성class ReferenceType { var property = 1}// 클래스 인스턴스 생성// 첫 번째 참조 생성// 두 개 다 같은 것이니까 아무거나 사용하삼 ~let firstClassReference : ReferenceType = ReferenceType()// let firstClassReference = ReferenceType()// 두 번째 참조 변수에 첫 번째 참조 할당let secondClassReference = firstClassReferenceprint(&quot;first class reference property : \\(firstClassReference.property)&quot;)// ----- 출력값// 1print(&quot;second class reference property : \\(secondClassReference.property)&quot;) // ----- 출력값// 1// 두 번째 참조를 통해 인스턴스의 프로퍼티 값 변경secondClassReference.property = 2// 두 번째 클래스 참조는 첫 번째 클래스 인스턴스를 참조하기 때문에// 두 번째 참조를 통해 인스턴스의 프로퍼티 값을 변경하면// 첫 번째 클래스 인스턴스의 프로퍼티 값도 변경 됨print(&quot;first class reference property : \\(firstClassReference.property)&quot;)// ----- 출력값// 2print(&quot;second class reference property : \\(secondClassReference.property)&quot;) // ----- 출력값// 2// 상수로 선언했어도 값이 바뀌는 이유는 // secondClassReference 자체를 변경한 것이 아닌 // secondClassReference가 바라보는 값을 변경하는 것이기 때문에 가능하다. 값 타입(Value Type) 데이터를 전달할 때 값을 복사하여 전달한다. 12345678910111213141516171819202122232425// 구조체 생성struct ValueType { var property = 1}// 첫 번째 구조체 인스턴스let firstStructInstance = ValueType()// 두 번재 구조체 인스턴스에 첫 번째 인스턴스 값 복사let secondStructInstance = firstStructInstance// 두번째 구조체 인스턴스 프로퍼티 값 수정secondStructInstance.property = 2// 두 번째 구조체 인스턴스는 첫 번째 구조체를 똑같이 복사한 // 별도의 인스턴스이기 때문에 // 두 번째 구조체 인스턴스의 프로퍼티 값을 변경해도// 첫 번째 구조체 인스턴스의 프로퍼티 값에는 영향이 없음print(&quot;first struct instance property : \\(firstStructInstance.property)&quot;)// ----- 출력값// 1print(&quot;second struct instance property : \\(secondStructInstance.property)&quot;)// ----- 출력값// 2 값 타입(Value Type)을 사용하는 경우 연관된 몇몇의 값들을 모아서 하나의 데이터 타입으로 표현하고 싶은 경우 다른 객체 또는 함수 등으로 전달될 때 참조가 아니라 복사(값 복사) 할 경우 자신을 상속할 필요가 없거나, 다른 타입을 상속 받을 필요가 없는 경우 스위프트에서의 사용 스위프트의 기본 데이터 타입은 모두 구조체로 구현되어있다. 스위스트는 구조체와 열거형 사용을 선호한다. Apple 프레임워크는 대부분 클래스를 사용한다. 구조체/클래스 선택과 사용은 개발자의 몫이다. 정리 클래스는 참조 타입이고, 데이터를 전달할 때 값의 메모리 위치를 전달한다. 두 번째 클래스가 첫 번째 클래스 인스턴스를 참조하기 할 때, 두 번째 클래스의 인스턴스 프로퍼티 값을 변경하면 첫 번째 클래스 인스턴스의 프로퍼티 값도 변경된다. 구조체는 값 타입입고, 데이터를 전달할 때 값을 복사하여 전달한다. 두 번째 구조체 인스턴스가 첫 번째 구조체를 복사하면 그것은 똑같이 복사된 별도의 인스턴스이기 때문에 두 번째 구조체 인스턴스의 프로퍼티 값을 변경해도 첫 번째 구조체 인스턴스의 프로퍼티 값에는 영향이 없다. class안에 struct 변수를 property로 정의하는것 가능하며, 반대로 struct의 property중 하나로 class 인스턴스 변수를 갖고있는 것도 가능하다. 이 경우 해당 struct 변수의 copy가 일어날때 class 인스턴스의 주소값만 복사된다. 우리가 사용하는 배열, 딕셔너리, 셋과 같은 컬렉션 타입은 구조체로서 구현되어 있다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 클래스 vs 구조체 / 열거형 Swift struct vs. class 차이점 비교 분석","link":"/2021/09/27/Swift/Class%20vs%20Struct/"},{"title":"Swift) Class란?","text":"Class란? 클래스는 참조(reference)타입이다. 타입 이름은 대문자 카멜케이스를 사용하여 정의한다.\u001c Swift의 클래스는 다중 상속이 되지 않는다. Class 문법 ‘class’ 키워드를 사용한다. 123class (대문자)이름 { /* 구현부 */}\u001c 프로퍼티 및 메서드 구현 1234567891011121314151617181920212223242526class Sample { // 가변 프로퍼티 var mutableProperty : Int = 100 // 불변 프로퍼티 let immutableProperty : Int = 100 // 타입 프로퍼티 static var typeProperty : Int = 100 // 인스턴스 메서드 func instanceMethod() { print(&quot;instance Method&quot;) } // 타입 메서드 // 상속시 재정의 불가 타입 메서드 - static static func typeMethod() { print(&quot;type Method - static&quot;) } // 상속시 재정의 가능 타입 메서드 - class class func classMethod() { print(&quot;type Method - class&quot;) }} 클래스 사용 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 인스턴스 생성 - 참조정보 수정 가능var mutableReference : Sample = Sample()mutableReference.mutableProperty = 200print(&quot;가변 인스턴스의 가변 프로퍼티 값은? &quot;,mutableReference.mutableProperty)// ----- 출력값// 가변 인스턴스의 가변 프로퍼티 값은? 200// 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다.// 컴파일 오류 발생// mutableReference.immutableProperty = 200// 인스턴스 생성 - 참조정보 수정 불가let immutableRefernce : Sample = Sample()// 클래스의 인스턴스는 참조타입이므로 let으로 선언되었더라도 인스턴스 프로퍼티의 값 변경이 가능하다.immutableRefernce.mutableProperty = 200print(&quot;불변 인스턴스의 가변 프로퍼티 값은?&quot;,immutableRefernce.mutableProperty)// ----- 출력값// 불변 인스턴스의 가변 프로퍼티 값은? 200// 다만 참조정보를 변경할 수는 없다.// 컴파일 오류 발생// immutableRefernce = mutableReference// 참조 타입이더라도 불변 인스턴스는// 인스턴스 생성 후에 수정할 수 없다.// 컴파일 오류 발생// immutableRefernce.immutableProperty = 200// 타입 프로퍼티 및 메서드Sample.typeProperty = 300print(&quot;타입 프로퍼티 값은?&quot;,Sample.typeProperty)// ----- 출력값// 타입 프로퍼티 값은? 300Sample.typeMethod()// ----- 출력값// type Method - static// 인스턴스에서는 타입 프로퍼티나 타입 메서드를 사용할 수 없다.// 컴파일 오류 발생// mutableReference.typeProperty = 200// mutableReference.typeMethod() 예제) 학생 클래스 만들어보기123456789101112131415161718192021222324252627282930313233343536373839class Student { // 가변 프로퍼티 var name : String = &quot;unknown&quot; // 키워드도 `로 묶어주면 이름으로 사용할 수 있다. var `class`: String = &quot;Swift&quot; // 타입 메서드 class func selfIntroduce() { print(&quot;학생 타입입니다.&quot;) } // 인스턴스 메서드 // self는 인스턴스 자신을 지칭하며, 몇몇 경우를 제외하고 사용은 선택사항이다. func selfIntroduce() { print(&quot;저는 \\(self.class)반 \\(name)입니다&quot;) }}// 타입 메서드 사용Student.selfIntroduce()// ----- 출력값// 학생 타입입니다.// 가변 인스턴스 생성var flora : Student = Student()flora.name = &quot;플로라&quot;flora.class = &quot;스위프트&quot;flora.selfIntroduce()// ----- 출력값// 저는 스위프트반 플로라입니다.// 불변 인스턴스 생성let sujeong : Student = Student()sujeong.name = &quot;수정&quot;sujeong.class = &quot;아이오에스&quot;sujeong.selfIntroduce()// ----- 출력값// 저는 아이오에스반 수정입니다. 정리 클래스에서 정의한 프로퍼티를 사용하고 싶다면 인스턴스 생성 후 프로퍼티를 사용할 수 있다. 그 중 타입 프로퍼티나 타입 메서드는 인스턴스 생성 없이 클래스 이름에 대입하여 바로 사용할 수 있다. 인스턴스 메서드는 생성한 인스턴스와 함께 사용할 수 있다. (타입 메서드와는 다름) 생성한 인스턴스에서는 타입 프로퍼티나 타입 메서드를 사용할 수 없다. 가변 인스턴스 생성 시 가변 프로퍼티는 수정이 가능하지만, 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다. 불변 인스턴스 생성 시 클래스의 인스턴스는 참조타입이므로 가변 프로퍼티 수정이 가능하지만 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다. 불변 인스턴스를 가변 인스턴스로 참조정보를 변경할 수 없다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 클래스","link":"/2021/09/24/Swift/Class/"},{"title":"Swift) Instance 메서드와 Type 메서드의 차이점을 설명하시오.","text":"Instance Method 특정 클래스, 구조체 또는 열거형의 인스턴스에 속하는 함수 특정 타입의 인스턴스에서 호출되는 메서드 12345678910111213141516class Sample { var something : String? func useInstanceMethod() { print(&quot;instance method!!&quot;) }}// 인스턴스 메서드를 사용하기 위해서는?// 1. 인스턴스를 생성해준다.var some : Sample = Sample()// 2. 인스턴스 메서드는 생성한 인스턴스와 함께 사용할 수 있다.some.useInstanceMethod()// ----- 출력값// instance method!! 📌 some이라는 인스턴스를 만들어주고, some의 내부함수인 useInstanceMethod()를 호출하여 값을 받을 수 있다.📌 여기서!! 인스턴스를 만들고 내부함수를 호출 한다는 것이 중요하다!! Type Method 타입 자체에서 호출되는 메서드 Type Method 키워드에는 Class와 Static이 있다. 이 두 키워드가 붙은 메서드는 인스턴스의 생성 없이 사용이 가능하다. Class 키워드 class 키워드는 class에서만 사용 가능하다. 1234567891011121314151617181920212223242526272829class SomeClass { // 인스턴스 메서드 func InstanceMethod() { print(&quot;Instance!!!&quot;) } // 타입 메서드 // 일반적인 클래스와는 쓰임새가 다르다. class func getSomething() { print(&quot;Type!!!&quot;) }}// 인스턴스 메서드 사용var some : SomeClass = SomeClass()// some.InstanceMethod()// ----- 출력값// Instance!!!// 타입 메소드로 지정한 것은 인스턴스 메소드처럼 사용이 불가능하다.// 에러// some.getSomething()// 타입 메서드는 타입 자체에서 호출해준다.SomeClass.getSomething()// ----- 출력값// Type!!! Class 키워드의 장점 반복적으로 일어나는 것을 처리하기에 좋다.인스턴스를 따로 생성하지 않기 떄문에 메모리 걱정을 할 필요가 없다. Class 키워드의 단점 확장성이 좋지 않다.당연한 값들로만 리턴을 하고, 초기화가 없기 떄문에 변수를 쓰지 못한다. Static 키워드 class 키워드와의 차이점은 override 가능 여부이다. static 키워드는 override가 불가하다. class 키워드는 해당 클래스를 상속 받았을 경우 오버라이드가 가능하다. class func를 하위 클래스에서 static func로 override하는 것도 가능하다. class 키워드 앞에 final 키워드를 붙이게 되면 override를 막을 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142// SomeClass를 SubClass가 상속받아 오버라이드 가능class SubClass: SomeClass { override class func getSomething() { print(&quot;wow&quot;) }}SubClass.getSomething() // ----- 출력값// wow// class func를 하위 클래스에서 // static func로 override 하는 것 가능class SubClass: SomeClass { override static func getSomething() { print(&quot;wow&quot;) }}SubClass.getSomething() // ----- 출력값// wow// SomeClass의 getSomething키워드를 static으로 변경한다면class SomeClass { func InstanceMethod() { print(&quot;Instance!!!&quot;) } // static으로 선언 static func getSomething() { print(&quot;Type!!!&quot;) }}class SubClass: SomeClass { // static method는 오버라이드가 불가하다라는 에러메시지가 뜬다. // error: Can not override static method override class func getSomething() { print(&quot;wow&quot;) }} 참고 Swift - 타입 메소드 &amp; 인스턴스 메소드 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 클래스","link":"/2021/10/06/Swift/Instance%20vs%20Type/"},{"title":"Swift) Optional이란 무엇인지 설명하시오.","text":"옵셔널(Optional)이란? 값이 있을수도 있고, 없을수도 있음을 표현 12345let optionalConstant : Int? = nil// 옵셔널이 아닌 상수에 nil값을 할당하려고 하면// 컴파일 오류 발생// let someConstant : Int = nil nil이 할당 될 수 있는지 없는지 표현\u001c 123456789101112// someOptionalParam에는 nil이 할당 될 수 있다.func someFunction(someOptionalParam:Int?) { // ...}// someParam에는 nil이 할당 될 수 없다.func someFunction(someParam:Int) { // ...}someFunction(someOptionalParam:nil)// someFunction(someParam:nil) 옵셔널을 사용하는 이유 명시적 표현 nil의 가능성을 코드만으로 표현 가능 문서/주석 작성 시간 절약\u001c 안전한 사용 전달받은 값이 옵셔널이 아니라면 nil체크를 하지 않고 사용가능 예외 상황을 최소화하는 안전한 코딩 효율적인 코딩 옵셔널 문법과 선언 옵셔널 문법 enum + generics 옵셔널 선언 12345678enum Optional&lt;Wrapped&gt; : ExpressibleByNiliteral { case none // 옵셔널에 값이 없다. case some(Wrapped) // 옵셔널 내외에 값이 있다.}// 옵셔널의 타입let optionalValue : Optional&lt;Int&gt; = nil // 완전한 문법let optionalValue : Int? = nil // 이렇게도 사용 가능 💡 물음표는 띄어쓰지 않는다! 옵셔널 표현! (Implicitly Unwrapped Optional) 암시적 추출 옵셔널 기존 변수처럼 사용 가능 1234567891011121314151617181920212223242526var optionalValue : Int! = 100switch optionalValue { case .none : print(&quot;This Optional variable is nil&quot;) case .some(let value) : print(&quot;Value is \\(value)&quot;)}// ----- 출력값// Value is 100// 기존 변수처럼 사용 가능optionalValue = optionalValue + 1print(optionalValue!)// ----- 출력값// 101// nil 할당 가능optionalValue = nilprint(optionalValue)// ----- 출력값// nil// optionalValue에 nil을 할당해놓은 상태에서 + 1을 해주면// 잘못된 접근으로 인한 런타임 오류 발생// optionalValue = optionalValue + 1 ? (General Optional) 기존 변수처럼 사용 불가 옵셔널과 일반 값은 다른 타입이므로 연산불가 12345678910111213141516171819var optionalValue : Int? = 100switch optionalValue { case .none : print(&quot;This Optional variable is nil&quot;) case .some(let value) : print(&quot;Value is \\(value)&quot;)} // ----- 출력값// Value is 100// nil 할당 가능optionalValue = nilprint(optionalValue)// ----- 출력값// nil// 기존 변수처럼 사용불가 - 옵셔널과 일반 값은 다른 타입이므로 연산불가// optionalValue = optionalValue + 1 옵셔널 추출 옵셔널에 들어있는 값을 사용하기 위해 꺼내오는 것이다. 옵셔널 바인딩 nil 체크 + 안전한 추출 옵셔널 안에 값이 있는지 확인하고, 값이 있으면 값을 꺼내온다. if-let 방식을 사용한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849func printName(_ name : String) { print(name)}var myName : String? = nil// printName은 기본 타입 그리고 myName은 옵셔널 타입으로 // 전달되는 값의 타입이 다르기 때문에 컴파일 오류발생// printName(myName)if let name : String = myName { printName(name)}else { print(&quot;myName == nil&quot;)}// ----- 출력값// myName == nil// name 상수는 if-let 구문 내에서만 사용가능하다.// 상수 사용범위를 벗어났기 때문에 컴파일 오류 발생// printName(name)var yourName : String! = nilif let name : String = yourName { print(name)}else { print(&quot;yourName == nil&quot;)}// ----- 출력값// yourName == nil// 쉼표(,)를 사용하여 한 번에 여러 옵셔널을 바인딩 할 수 있다.// 모든 옵셔널에 값이 있을 때만 동작한다.myName = &quot;sujeong&quot;yourName = nil// yourName이 nil이기 때문에 실행되지 않는다.// if let name = myName, let friend = yourName {// print(&quot;\\(name) and \\(friend)&quot;)// }yourName = &quot;wonseok&quot;if let name = myName, let boyFriend = yourName { print(&quot;\\(name) and \\(boyFriend)&quot;)}// ----- 출력값// sujeong and wonseok 강제추출 옵셔널에 값이 들어있는지 아닌지 확인하지 않고, 강제로 값을 꺼내는 방식이다. 만약 값이 없을경우(nil) 런타임 오류가 발생하기 때문에 추천하지 않는다. 1234567891011121314151617181920212223func printName(_ name: String) { print(name)}// 옵셔널의 값을 강제로 꺼내와서 전달하고자 한다면, // myName의 옵셔널 물음표가 벗겨지면서 안에 있던 값 sujeong이 강제로 추출되어 (myName!)에 들어온다. // 그러므로 옵셔널 타입이 아닌 스트링 타입 printName으로 값을 넘겨줄 수 있는 것이다.var myName : String? = &quot;sujeong&quot;var yourName : String! = nilprintName(myName!)// ----- 출력값// sujeongmyName = nil// 강제추출시 값이 없으므로 런타임 오류 발생// print(myName!)yourName = nil// nil 값이 전달되기 때문에 런타임 오류 발생// printName(yourName) 옵셔널 체이닝 옵셔널의 내부의 내부의 내부로 옵셔널이 연결되어 있을 때 유용하게 활용할 수 있다. 매번 nil 확인을 하지 않고 최종적으로 원하는 값이 있는지 없는지 확인할 수 있다. 예제12345678910111213141516171819202122232425262728293031// 사람 클래스class Person { var name : String var job : String? var home : Apartment? init(name : String) { self.name = name }}// 사람이 사는 집 클래스class Apartment { var buildingNumber : String var roomNumber : String var `guard` : Person? var owner : Person? init(dong : String, ho : String) { buildingNumber = dong roomNumber = ho }}// 옵셔널 체이닝 사용let sujeong : Person? = Person(name:&quot;sujeong&quot;)let apart : Apartment? = Apartment(dong:&quot;307&quot;,ho:&quot;1203&quot;)let superman : Person? = Person(name:&quot;superman&quot;)// 옵셔널 체이닝 실행 후 결과값이 nil일 수 있으므로 // 결과 타입도 옵셔널이다. 만약 우리집 경비원 직업이 궁금하다면?1234567891011121314151617181920212223242526272829// 옵셔널 체이닝을 사용하지 않는 경우func guardJob(owner: Person?) { if let owner = owner { if let home = owner.home { if let `guard` = home.guard { if let guardJob = `guard`.job { print(&quot;우리집 경비원의 직업은 \\(guardJob)입니다.&quot;) } else { print(&quot;우리집 경비원은 직업이 없어요.&quot;) } } } }}guardJob(owner: sujeong)// 옵셔널 체이닝을 사용하는 경우func guardJobWithOptionalChaining(owner: Person?) { if let guardJob = owner?.home?.guard?.job { print(&quot;우리집 경비원의 직업은 \\(guardJob)입니다.&quot;) } else { print(&quot;우리집 경비원은 직업이 없어요.&quot;) }}guardJobWithOptionalChaining(owner: sujeong)// ----- 출력값// 우리집 경비원은 직업이 없어요. nil 병합 연산자 ?? 중위 연산자 Optional ?? Value 옵셔널 값이 nil 일 경우, 우측 값을 반환한다. 띄어쓰기에 주의 12345678910111213var guardJob : StringguardJob = sujeong?.home?.guard?.job ?? &quot;슈퍼맨&quot;print(guardJob)// ----- 출력값// 경비원sujeong?.home?.guard?.job = nilguardJob = sujeong?.home?.guard?.job ?? &quot;슈퍼맨&quot;print(guardJob)// ----- 출력값// 슈퍼맨 정리 옵셔널은 값이 있을수도, 없을수도 있음을 표현한다. 옵셔널이 아닌 상수에 nil값을 할당하려고 하면 컴파일 오류가 발생한다. 옵셔널은 열거형(enum)과 general의 합작품이라고 볼 수 있다. !(Implicitly Unwrapped Optional)은 기존 변수처럼 사용이 가능하다. ?(General Optional)은 옵셔널과 일반 값은 다른 타입이므로 기존 변수처럼 사용이 불가하다. 옵셔널 바인딩은 옵셔널 안에 값이 있는지 확인하고, 값이 있으면 값을 꺼내오며 if-let 방식을 사용한다. 옵셔널 바인딩 시 선언한 상수는 if-let 구문 내에서만 사용할 수 있으며, 상수의 사용 범위를 벗어나면 컴파일 오류가 발생한다. 쉽표(,)를 통해 한번에 여러 옵셔널을 바인딩 할 수 있는데, 모든 옵셔널에 값이 있어야만 동작한다. 강제추출은 옵셔널에 값이 들어있는지 아닌지 확인하지 않고, 강제로 값을 꺼내는 방식이다. 강제추출은 옵셔널로 선언되어 있는 값을 강제로 추출한 후 옵셔널 타입이 아닌 다른 타입으로 값을 넘겨줄 수 있다. 옵셔널 체이닝은 옵셔널의 내부의 내부의 내부로 옵셔널이 연결되어 있을 때 유용하며, 최종적으로 원하는 값이 있는지 없는지를 확인한다. 옵셔널 체이닝 시, if-let 안에 들어있는 값들을 순서대로 확인하고 그 중 하나라도 값이 없다면, 멈춘 후 else문을 출력한다. nil 병합 연산자는 ?? 이렇게 표현하며, 옵셔널 값이 nil 일 경우 우측 값을 반환한다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 옵셔널 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 옵셔널 추출 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 옵셔널 체이닝과 nil 병합","link":"/2021/03/23/Swift/Optional/"},{"title":"Swift) Struct가 무엇이고 어떻게 사용하는지 설명하시오.","text":"Struct란? Swift 대부분 타입은 구조체로 이루어져 있다. 구조체는 값(value)타입이다. 타입 이름은 대문자 카멜케이스를 사용하여 정의한다.\u001c Struct 문법 ‘struct’ 키워드로 구조체를 정의한다. 123struct (대문자)이름 { /* 구현부 */}\u001c 구조체 프로퍼티 및 메서드 구현 1234567891011121314151617struct Sample { // 가변 프로퍼티(값 변경 가능) var mutableProperty:Int = 100 // 불변 프로퍼티(값 변경 불가능\u001d) let immutableProperty:Int = 100 // 타입 프로퍼티(static 키워드 사용: 타입 자체가 사용하는 프로퍼티) static var typeProperty:Int = 100 // 인스턴스 메서드(인스턴스가 사용하는 메서드) func instanceMethod() { print(&quot;instance method&quot;) } // 타입 메서드(static 키워드 사용: 타입 자체가 사용하는 메서드) static func typeMethod() { print(&quot;type method&quot;) }}\u001c 구조체 사용 123456789101112131415161718192021222324252627282930313233343536373839404142// 가변 인스턴스 생성var mutable: Sample = Sample()mutable.mutableProperty = 200print(&quot;변경된 가변 프로퍼티 값은? &quot;,mutable.mutableProperty)// ----- 출력값// 변경된 가변 프로퍼티 값은? 200// 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다.// 컴파일 오류 발생// mutable.immutableProperty = 200// 불변 인스턴스 생성let immutable: Sample = Sample()// 불변 인스턴스는 아무리 가변 프로퍼티라도// 인스턴스 생성 후에 수정할 수 없다.// 컴파일 오류 발생// immutable.mutableProperty = 200// immutable.immutableProperty = 200// 타입 프로퍼티 및 메서드// 타입 프로퍼티는 인스턴스를 생성하지 않고 바로 사용할 수 있다.Sample.typeProperty = 300print(&quot;타입 프로퍼티의 변경된 값은 &quot;,Sample.typeProperty)// ----- 출력값// 타입 프로퍼티의 변경된 값은 300Sample.typeMethod()// ----- 출력값// type method// 인스턴스에서는 타입 프로퍼티나 타입 메서드를// 사용할 수 없다.// 컴파일 오류 발생// mutable.typeProperty = 400// mutable.typeMethod()// 인스턴스 메서드 mutable.instanceMethod()// ----- 출력값// instance method 예제) 학생 구조체 만들어보기1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Student { // 가변 프로퍼티 var name : String = &quot;unknown&quot; // 키워드도 `로 묶어주면 이름으로 사용할 수 있다. var `class`: String = &quot;Swift&quot; // 타입 메서드 static func selfintroduce() { print(&quot;학생 타입 입니다.&quot;) } // 인스턴스 메서드 // self는 인스턴스 자신을 지칭하며, 몇몇 경우를 제외하고 사용은 선택사항 func selfintroduce() { print(&quot;저는 \\(self.class)반 \\(name)입니다.&quot;) } // 타입 메서드 사용 Student.selfintroduce() // ----- 출력값 // 학생 타입 입니다. // 가변 인스턴스 생성 var flora : Student = Student() // 프로퍼티 사용 flora.name = &quot;플로라&quot; flora.class = &quot;스위프트&quot; // 인스턴스 메서드 사용 flora.selfintroduce() // ----- 출력값 // 저는 스위프트반 플로라입니다. // 불변 인스턴스 생성 let sujeong : Student = Student() // 불변 인스턴스이므로 프로퍼티 값 변경 불가 // 컴파일 오류 발생 // sujeong.name = &quot;수정&quot; sujeong.selfintrodeuce() // ----- 출력값 // 저는 Swift반 unknown입니다.} 정리 구조체에서 정의한 프로퍼티를 사용하고 싶다면 인스턴스 생성 후 프로퍼티를 사용할 수 있다. 그 중 타입 프로퍼티나 타입 메서드는 인스턴스 생성 없이 구조체 이름에 대입하여 바로 사용할 수 있다. 인스턴스 메서드는 생성한 인스턴스와 함께 사용할 수 있다. (타입 메서드와는 다름) 가변 인스턴스 생성 시 가변 프로퍼티는 수정이 가능하지만, 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다. 불변 인스턴스 생성 시 가변 프로퍼티, 불변 프로퍼티 둘 다 인스턴스 생성 후에 수정할 수 없다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 구조체","link":"/2021/09/23/Swift/Struct/"},{"title":"Swift) Singleton Pattern에 대해 설명하시오.","text":"Singleton Pattern 특정 용도로 객체를 하나만 생성하여, 공용으로 사용하고 싶을 때 사용하는 디자인 유형 123456// User의 정보를 저장하는 클래스class UserInfo { var id: String? var password: String? var name: String?} 위와 같은 UserInfo 클래스가 있을 때,A ViewController에서는 id, B ViewController에서는 password, C ViewController에서는 name을 입력받아 전달해야 한다고 생각해보자. 12345678910111213//A ViewControllerlet userInfo = UserInfo()userInfo.id = &quot;suzumsz&quot;//B ViewControllerlet userInfo = UserInfo()userInfo.password = &quot;123&quot;//C ViewControllerlet userInfo = UserInfo()userInfo.name = &quot;sujeong&quot;// 클래스로 선언했으니 뷰 컨트롤러마다 인스턴스를 만들어 값을 할당해줘야한다. 이렇게 A, B, C ViewController에 각각 UserInfo 객체를 만들어서 저장하면, 💡 한 인스턴스에 모든 정보가 저장되는 것이 아닌, 위 사진처럼 각 Instance의 프로퍼티에만 값이 저장되는 것을 볼 수 있다. 위와 다르게, 한 인스턴스에 모든 정보를 저장하고 싶다면?UserInfo를 싱글톤으로 만들어 사용하기 클래스에 대한 Instance는 최초 생성될 때 딱 한번만 생성해서 전역에 두고, 그 이후로는 이 Instance만 접근 가능하게 한다. 💡 한 인스턴스로 어느 클래스에서든 접근이 가능하다. Singleton Class 만드는 법static 프로퍼티로 인스턴스 생성하기 전역으로 저장될 것이므로, static을 이용해 Instance를 저장할 프로퍼티를 하나 생성한다. 1234567class UserInfo { static let shared = UserInfo() var id: String? var password: String? var name: String?} init 함수 접근제어자를 private로 지정하기 혹시라도 init 함수를 호출해 Instance를 또 생생하는 것을 막기 위해, init() 함수 접근 제어자를 private로 지정해주면 된다. 123456789class UserInfo { static let shared = UserInfo() var id: String? var password: String? var name: String? private init() { }} Singleton Class 접근하는 방법 어느 클래스에서든 shared라는 static 프로퍼티로 접근하면, 하나의 Instance를 공유할 수 있다. 1234567891011//A ViewControllerlet userInfo = UserInfo.shareduserInfo.id = &quot;suzumsz&quot;//B ViewControllerlet userInfo = UserInfo.shareduserInfo.password = &quot;123&quot;//C ViewControllerlet userInfo = UserInfo.shareduserInfo.name = &quot;sujeong&quot; Singleton Pattern의 장단점장점 한 번의 Instance만 생성하므로 메모리 낭비를 방지할 수 있다. Singleton Instance는 전역 Instance로 다른 클래스들과의 자원 공유가 쉽다. DBCP(DataBase Connection Pool)처럼 공통된 객체를 여러개 생성해서 사용해야하는 상황에서 많이 사용 (쓰레드풀, 캐시, 대화상자, 사용자 설정, 레지스트리 설정, 로그 기록 객체 등) 단점 Singleton Instance가 너무 많은 일을 하거나, 많은 데이터를 공유시킬 경우 다른 클래스의 Instance들 간 결합도가 높아져 “개방=폐쇄” 원칙을 위배한다. (객체 지향 설계 원칙 어긋남) 수정과 테스트가 어려워진다. iOS Cocoa 프레임워크에서는 많은 싱글톤 패턴을 사용많은 곳에 사용되는 Singleton Pattern12345let screen = UIScreen.mainlet userDefault = UserDefaults.standardlet application = UIApplication.sharedlet fileManager = FileManager.defaultlet notification = NotificationCenter.default 참고 개발자 소들이 - 싱글톤 패턴(Singleton Pattern) Swift Singleton Pattern","link":"/2021/10/11/Swift/Singleton%20Pattern/"},{"title":"Swift) Strategy Pattern이란?","text":"Strategy Pattern 클래스의 행위를 캡슐화 하여 동적으로 행위를 자유롭게 바꿀 수 있도록 돕는 패턴이다. Strategy Pattern 구성요소 3가지 Strategy를 사용할 객체 Strategy를 정의하는 프로토콜 2번의 프로토콜을 구현한 Strategy객체 두 개 이상의 유사한 동작이 필요하고, 이 동작이 유연하게 바뀌기를 원할 때 사용하면 좋다.구성요소만 봐도 Delegate Pattern과 굉장히 유사하다는 것을 알 수 있다. Strategy Pattern은 언제 사용하나요? 어떤 상황에서 사용할 알고리즘이 여러 개 존재할 수 있을 때 사용하면 좋다. 런타임에서 변경이 가능하기 때문에 이와 같은 상황에 효과적으로 대응할 수 있다. ex) 네비게이션을 개발했다고 가정해보면? 출시 당시, 자동차의 경로만 알려주는 내비게이션 이후 사용자의 증가로 인해 도보로 이동하는 사람의 경로, 대중교통을 이동하는 사람의 경로 등 다양한 알고리즘이 필요 하지만 이를 위해 클래스 안에 계속해서 구현하다 보면, 하나의 변경으로 인해 많은 곳을 수정해야 하는 문제가 발생한다. 이를 해결하기 위해 Strategy Pattern을 사용 할 수 있다.자동차의 경로, 도보로 이동하는 경로, 대중교통 경로에 대한 알고리즘을 따로 구현하고 이들을 캡슐화한다.각각의 알고리즘은 서로에게 영향을 주지 않고 각자 독립적으로 작동하도록 만들어주어 위와 같은 문제를 해결할 수 있다. 위의 예시를 예제로! 먼저 Strategy 인터페이스 역할을 할 프로토콜을 하나 정의해준다. 1234// Strategyprotocol Strategy { func algorithmExecute()} 그 다음으로는 Strategy 프로토콜을 채택하는 알고리즘들을 만들어준다. 12345678910111213141516171819202122// 네비게이션으로 자동차, 도보, 자전거 경로를 알고 싶으니 Strategy 프로토콜을 채택한 3개의 클래스를 만들어준다.// Concrete Strategyclass CarRoute: Strategy { func algorithmExecute() { print(&quot;자동차 경로 찾기 완료!\\n&quot;) }}// Concrete Strategyclass WalkRoute: Strategy { func algorithmExecute() { print(&quot;도보 경로 찾기 완료!\\n&quot;) }}// Concrete Strategyclass BikeRoute: Strategy { func algorithmExecute() { print(&quot;자전거 경로 찾기 완료!\\n&quot;) }} 만든 알고리즘들을 교체해가며 사용할 Context를 구현한다. 12345678910111213// Strategy 객체를 참조하고 있는 Context 클래스// Contextclass Navigation { private var routeAlgorithm: Strategy? func execute() { self.routeAlgorithm?.algorithmExecute() } func setStrategy(strategy: Strategy) { self.routeAlgorithm = strategy }} 실제로 사용해본다면? 런타임에서 계속해서 Strategy 객체를 변경하며 다른 알고리즘을 사용하는 것을 볼 수 있다. Strategy Pattern의 장단점장점 런타임에서 객체 내부에서 사용되는 알고리즘을 변경 할 수 있다. 알고리즘을 사용하는 코드와 알고리즘을 구현하는 코드를 분리할 수 있다. Open / Closed Principle(개방 폐쇄 원칙)을 준수한다. Context를 변경하지 않고도 새로운 Strategy를 도입할 수 있다. 단점 알고리즘이 몇 개 없고 변경되는 일도 거의 없는 경우 전략 패턴의 도입이 오히려 복잡성을 증가시킬 수 있다. 클라이언트가 적절한 Strategy를 선택하기 위해서는 각각의 차이점을 알고 있어야 한다. Strategy, Context간 통신 오버헤드가 발생한다. 참고 [Swift 디자인 패턴] Strategy Pattern (전략) Strategy Pattern (with iOS, Swift)","link":"/2021/10/20/Swift/Strategy%20Pattern/"},{"title":"회고) RisingCamp 1기 회고 및 후기","text":"RisingCamp 1기를 시작하기까지2021년 3월 맥북을 산 후, 난 처음으로 iOS 개발을 시작했다.어디서부터 무엇을 어떻게 해야하는지에 대해 전혀 감이 오지 않아서 주변 친구들에게 많은 것을 물어봤던 기억이 난다. 그 중 &quot;앱 개발 동아리 들어가면 체계적으로 배우면서 성장할 수 있을거야&quot; 라는 말을 듣고 iOS 파트가 있는 동아리에 이곳저곳 지원했다. 하지만 결과는 불합격! 아는 것이 1도 없는 상태라 그런지 떨어졌던 것 같다. 뭐라도 해보자라는 심정으로 ‘캠퍼스픽’ 앱을 통해 iOS 클론 코딩 스터디원을 구하기 시작했다. 사람들을 모아서 스터디를 진행하는 것이 처음이라 쉽지는 않았지만 다행히 좋은 스터디원을 만나 진행할 수 있었다. '클론 코딩 스터디' 애플뮤직, 인스타그램을 클론하는 스터디를 주관하여 진행하였다. 날짜를 정해 프로젝트를 완성한 후 줌으로 자신의 코드를 발표하고 공유하면서 iOS 개발에 좀 더 익숙해질 수 있었다. 클론 코딩 스터디를 하면서도 iOS 관련한 활동을 꼭 해보고 싶었다. 그래서 한참 찾아보던 중 ‘라이징 프로그래머’를 하던 친구의 추천으로 라이징 캠프라는 프로그램을 알게되었다. 다른 동아리 활동과 달리 RisingCamp는 선착순으로 진행되었다. 체계적으로 잘 배워볼 수 있는 커리큘럼인 것 같아서 너무너무 하고싶었다.8주 안에 iOS에 대해 완벽하게 배워 볼 수 있다는 것이 너무 매력적이었고 나에게는 마지막 기회인 것 같이 느껴졌던 것 같다. RisingCamp 1기 시작!21.06.19 ~ 21.08.13까지 8주간 진행되는 커리큘럼은 이러하다. 1주차 OT &amp; 플랫폼1주차 때에는 Zigzag 앱을 클론코딩 하였다. 1주차의 목표는 이러하다.123456789101. 실제 프로덕트 애플리케이션 프론트 구성 - 최대한 똑같이 구성 2. 다양한 기기별 해상도를 고려하여 구성 - AutoLayout 3. 다양한 Objects Library 사용해보기4. 코드는 최대한 사용 x - 스토리보드로만 구성 클론 코딩을 해봤던 것이 많은 도움이 되어 1주차는 별로 어렵지 않게 진행했던 것 같다.목표했던 것을 가장 부합하게 잘 해왔다는 칭찬도 받았던 주차라 기분좋게 2차 세션을 들었던 것 같다 ㅎㅎ아쉬운 점을 꼽자면 더 다양한 Objects Library 사용해 봤다면 좋았을 것 같다. 2주차 Life Cycle2주차 때에는 메모장 앱을 개발하였다. 2주차의 목표는 이러하다.123451. 생명주기를 활용한 프로그래밍2. 화면전환3. CRUD(Create/Read/Update/Delete) 2주차에 너무 어려운 앱을 하지 않았나라는 생각이 들었다. 정말 간단해 보여서 했던 거였는데 ㅠ 아니었다,,뷰 컨트롤러 1에서 뷰 컨트롤러 2로 데이터 전달하는 것은 쉬웠지만, 뷰 컨트롤러 2에서 뷰 컨트롤러 1로 데이터 전달하는 것이 어려웠던 기억이 난다. 또한 아직 배우지 않은 테이블 뷰로 진행했어서 좀 더 까다로웠던 것 같다. 다음 주차 때 배울 걸 미리 해서 다음 주차는 좀 더 쉽게 적용해 볼 수 있을 것 같았다! 3주차 Table View3주차 때에는 반려동물 사진 일기 앱을 개발하였다. 3주차의 목표는 이러하다.1231. Delegate로 DataPassing 해주어 데이터 전달2. TableView를 사용한 앱 만들기 강아지를 키우다보니 강아지 관련 앱을 꼭 만들어보고 싶었는데 과제 때 해볼 수 있어서 너무 좋았다.해당 주보다 전에 이미 과제를 비슷하게 수행했던 기억이 있어 어렵지 않게 진행할 수 있었다. 그래서 이번 주차에는 컬렉션 뷰와 다른 기능들을 더 써보려고 노력했던 것 같다.아쉬운 점이 있다면 bottom sheet를 완벽하게 구현하지 못한 점이 아쉬웠다. 4주차 Multi-Thread4주차 때에는 슈의 얼려먹는 초코 만들기 게임을 개발하였다. 4주차의 목표는 이러하다.123451. Multi-Thread를 사용한 게임 만들어보기2. UIKit만 사용하여 만들어보기 (라이브러리x)3. Dispatch를 사용해보며 내부적으로 어떻게 동작하는지 알기 개인적으로 이번 주차가 가장 어렵고 힘들었던 것 같다. 아무것도 사용하지 않고 UIKit만을 이용하여 게임을 만들어야 한다는 점이 당황스러웠다.과제에 대해 이해가 잘 안되서 2일 정도를 계속 생각하고 멘토님께 여쭤보았던 것 같다.게임을 정하고 누끼따는 것도 정말 힘든 일 중 하나였다 ㅋㅋㅋㅋ 그래도 막상 만들어보고 나니 Dispatch에 대해 제대로 이해할 수 있었던 활동인 것 같다. 5주차 Network Intro &amp; API5주차 때에는 강아지 산책 을 개발하였다. 5주차의 목표는 이러하다.1234567891. OPEN API 활용하여 프로그래밍 하기(SDK 사용 지양)2. 소셜 로그인 최소 한가지 이상 구현하기 (단순히 화면 전환이 아닌 이름,이메일 값을 활용한 프로그래밍) ❗️단, 소셜 로그인은 SDK 허용3. Postman 활용 / Alamofire 활용4. 5개 페이지 구현하기 강아지 관련 앱을 하나 더 만들어보았는데 지금까지 했던 것들 보다는 제대로 된 앱을 만들었던 것 같다. 실제 카카오 로그인도 사용해보고 로그인한 데이터를 가지고 사용자 정보를 입력받는 등 실제의 앱과 가장 유사한 앱을 만들 수 있었던 주차였다. 날씨 api를 가져다가 서버 통신도 해보고 url session으로 되어있는 코드를 alamofire로 바꿔 동작할 수 있도록 진행했다.하지만 api 서버 통신에 대해 완벽히 이해가 되지 않아 계속적인 공부가 필요하다고 느꼈고 그 점이 라이징 테스트에 가서 그렇게 힘들 줄 몰랐다 하하,, 6주차 Token &amp; Restful6주차 때에는 Token &amp; Restful에 대해 배워보고 과제는 없었다!!그래서 이번 주차는 라이징 테스트를 준비하기위해 ‘모듈화 작업’ 및 ‘API 공부’를 진행하였다. 라이징 테스트를 대비하기 위해 모든 앱에 기본적으로 있는 기능들을 위주로 모듈화 작업을 진행하였다. 개인적인 생각이지만 이 주차에서는 아무것도 안하고 쉬는 것도 좋다고 생각한다 ㅎㅎ,, 2주간 많이 힘들거기 때문에 조금이라도 쉬는 타임을 갖는 것도 좋을 것 같다. 난 처음이라 불안 + 초초한 마음 때문에 안쉬고 공부를 했던 것 같은데 그렇게 되니 라이징 테스트 때 많이 힘들었던 것 같다. 7~8주차 대망의 Rising Test7~8주차 때에는 라이징 테스트를 진행한다. 나는 요기요 앱이 걸렸고 iOS(1명)와 서버(1명)가 한팀으로 이루어져 2주간 개발을 진행한다. 서버와의 첫 협업이라 긴장도 되고, 어떤식으로 협업을 진행해야하는지 감이 안잡혀 정말 어려웠다. 다행히 서버분도 클라이언트와의 협업이 처음이라고 하셔서 모르는 것은 대화를 통해 해결하자고 했던 것 같다. 그렇게 서로 노력한 덕분에 나름대로 재밌었던 협업 경험이 된 것 같다. 라이징 테스트를 하면서 힘들었던 것은 시간은 촉박한데 하루 설정했던 목표치 만큼 못할 때 심적으로 스트레스가 컸던 것 같다. 시간이 주는 촉박함이 부담감으로 다가왔던건지 중도 포기할까? 라는 생각도 많이 했던 것 같다. 라이징 테스트를 하면서 아쉬웠던 점은 서버와의 협업을 미리 조금이라도 경험해봤다면 좀 더 좋은 결과물을 내지 않았을까? 였다. 물론 부딪혀보면서 배우는 것도 방법이지만, 2주 안에 해야하는 양은 정해져있는데 명세서를 받고나면 뭘 어떻게 해야하는지 조차 모르는 상태였기 때문에 몇 일은 그걸 공부하느라 시간을 보냈던 것 같다. 수료 라이징 테스트를 하면서 힘든 시간을 보냈지만, 수료를 했다는 것이 너무 뿌듯했다. 처음엔 iOS 기초밖에 몰랐는데 라이징 캠프를 통해서 개발 실력이 정말 많이 향상된 것 같다. 라이징 캠프는 주차별 과제 때도 그렇고 언제나 자신의 한계에 부딪히게 하는 맛이 있는 것 같다. 당장 할 때는 잠도 못 자고 할 만큼 힘들었지만 지나고 나니 뿌듯한 결과물과 향상된 실력이 이를 증명해주는 것 같아서 좋은 것 같다.물론 나보다 더 쉽고 편하게 진행한 사람들도 많겠지만 나는 아니었다 ㅋㅋㅋㅋ 힘들었다 ㅋㅋㅋㅋ 라이징 캠프에서 가장 좋았던 점은 너무너무 좋은 멘토님과 친해진 동기들인 것 같다. 힘들때마다 응원해주셔서 버틸 수 있었던 것 같고, 멘토님은 언제나 빠른 답변으로 문제를 해결해주셔서 iOS를 더욱 재미있게 공부할 수 있었던 것 같다. RisingCamp를 하고싶다면아무것도 모른다면 더욱 힘들다.주차별 과제를 할 때에 앞서 공부했던 클론코딩이 정말 많이 도움이 되었던 것 같다. 또한 라이징 테스트에서는 로직을 짜는 것이 너무 어려웠었는데, 그런 로직을 어렵지않게 잘 짜고싶다면 관련 언어의 알고리즘에 대한 지식이 조금이라도 있다면 더 좋을 것 같다고 느꼈다. 모든지 더 하자라이징 테스트 때에는 실제 앱이다보니 안사용하는 기능이 없을만큼 많은 기능을 사용하게 된다. 그때 처음 써서 공부하는 것 보다는 주차별 과제를 할 때 더 많은 기능을 사용해보고 미리 공부해본다면 더 좋은 결과를 얻을 수 있을 것 같다. 한계에 도전하고 싶은 사람개인적인 생각이지만 관련 파트를 처음 시작하는 사람들에게는 자신의 한계를 경험해 볼 수 있는 것 같다. 과제 선정을 할 때 내가 얼마나 더 도전하고 싶은가에 따라 더 어려운지 쉬운지가 나뉘겠지만 쉬울 것 같다고 생각했던 앱 조차 나는 힘들었다,, 위에 말한거처럼 자신의 한계를 경험해 볼 수 있는데, 그만큼 정말 많이 성장할 수 있다. 그러한 경험을 하고 싶고 그만큼 성장을 원하는 분들이라면 도전하는 것을 추천한다.","link":"/2021/09/02/%ED%9A%8C%EA%B3%A0/RisingCamp/"},{"title":"Python) 체육복","text":"난이도 : Level 1유형 : 탐욕법 (Greedy)카테고리 : 프로그래머스날짜 : 2022-02-07 문제 풀이제한사항 중 중복이 없다, 여벌의 체육복이 있는 학생도 도난 당할 수 있다 라는 점을 유의해서 풀었다. 여기서 중복이 없다.는 12reserve = [`1`,`1`,2] 일 때, 배열 내 1 중복 불가 lost = [`2`,3,1,`2`] 일 때, 배열 내 2 중복 불가 를 말한다. 여벌의 체육복이 있는 학생도 도난 당할 수 있다.는 lost 값에 reserve값이 공통적으로 존재할 수 있음을 말한다. 1reserve = [`2`,3,4]와 lost = [1,`2`,3] 일 때, 배열 내 2가 공통적으로 존재할 수 있음 이 때 여벌의 체육복은 1개밖에 없다고 가정하기 때문에 reserve와 lost에 같은 값이 있다면 그 값은 reserve에서 제외시켜줘야 한다. reserve의 요소들 중 lost에 동일하게 존재하는 값을 set을 사용하여 모두 제거한다. 12_reserve = set(reserve) - set(lost)_lost = set(lost) - set(reserve) 체육복을 양 옆으로 나눠줄 수 있도록 하기 위해 왼쪽부터 탐색한다. 12345for i in _reserve : if i-1 in _lost : # 왼쪽부터 _lost.remove(i-1) elif i+1 in _lost : # 오른쪽 _lost.remove(i+1) 총 학생 수(n)에서 체육복을 잃어버린 학생 수(lost)를 빼준다면 체육 수업을 들을 수 있는 학생의 수를 알 수 있다. 12for i in _reserve : return n-len(_lost) 전체 코드123456789101112131415def solution(n, lost, reserve):# n : 전체 학생의 수# lost : 체육복을 도난당한 학생들의 번호가 담긴 배열# reverse : 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 _reserve = set(reserve) - set(lost) _lost = set(lost) - set(reserve) for i in _reserve : if i-1 in _lost : _lost.remove(i-1) elif i+1 in _lost : _lost.remove(i+1) return n-len(_lost) 다른 사람의 풀이제한사항을 set이 아닌 not in 컴프리헨션으로 처리하였다.for문 돌면서 foward, back을 확인하고, remove를 해주었다. 12345678910111213def solution(n, lost, reserve): _reserve = [r for r in reserve if r not in lost] _lost = [l for l in lost if l not in reserve] for r in _reserve: f = r - 1 b = r + 1 if f in _lost: _lost.remove(f) elif b in _lost: _lost.remove(b) return n - len(_lost)","link":"/2022/02/07/Python/%EC%B2%B4%EC%9C%A1%EB%B3%B5/"},{"title":"Python) 문자열 내림차순으로 배치하기","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-08 문제 풀이간단한 문제로 쉽게 풀 수 있었다. 먼저 sorted를 사용하여 정렬을 해주었고, reverse = True로 내림차순을 나타냈다. 1sorted(s, reverse = True) 내림차순으로 배치한 문자열을 합쳐주기 위해 join을 이용하였다. 1''.join(sorted(s, reverse = True)) 전체 코드12def solution(s): return ''.join(sorted(s, reverse = True))","link":"/2022/02/08/Python/%EB%AC%B8%EC%9E%90%EC%97%B4%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Python) 정수 내림차순으로 배치하기","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-08 문제 풀이‘문자열 내림차순으로 배치하기’ 문제와 비슷한 문제였다. 먼저 정렬을 사용하기 위해서 정수형 int를 문자열 str로 변환해주었다. 1n = list(str(n)) 내림차순으로 배치한 문자열을 합쳐주기 위해 join을 이용하였다. 1''.join(sorted(n, reverse = True)) 문자열에서 정수형으로 변경하기 위해 int형으로 감싸 리턴해주었다. 1int(''.join(sorted(n, reverse = True))) 전체 코드123def solution(n): n = list(str(n)) return int(''.join(sorted(n, reverse = True)))","link":"/2022/02/08/Python/%EC%A0%95%EC%88%98%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Python) 자연수 뒤집어 배열로 만들기","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-08 문제 풀이앞서 풀었던 문제들과 비슷한 문제 유형이었다. 정렬을 하기위해 배열 list를 만들어주고, 정수형을 문자열로 변경해주었다. 1list(str(n)) 내림차순으로 배치하기 위해 reversed를 사용했다. 1reversed(str(n)) 문자열이 아닌 정수형 리스트로 변경되어야 하기 때문에, map을 이용해 int형으로 변환해주었다. 1list(map(int, ~) 전체 코드12def solution(n): return list(map(int, reversed(str(n)))) reverse() 와 reversed() 차이list.reverse() 📌 메모리 내의 배열 원소를 직접 수정📌 반환 값은 None 12345678910array1 = [1, 5, 3, 9, 7, 2]array2 = array.reverse()print(&quot;array1이 직접 역순이 됩니다 :&quot;,array1)# 출력값# array1이 직접 역순이 됩니다 : [2, 7, 9, 3, 5, 1]print(&quot;array2에는 역순된 array가 들어가지 않습니다 :&quot;,array2)# 출력값 # array2에는 역순된 array가 들어가지 않습니다 : None reversed(list) 📌 반환값이 배열값으로 변수에 저장 가능📌 원래 변수는 수정되지 않음 12345678910array1 = [1, 5, 3, 9, 7, 2]array2 = sorted(array)print(&quot;array1은 역순이 되지 않습니다 :&quot;,array1)# 출력값# array1은 역순이 되지 않습니다 : [1, 5, 3, 9, 7, 2]print(&quot;array2에는 역순된 array가 들어갑니다 :&quot;,array2)# 출력값 # array2에는 역순된 array가 들어갑니다 : [2, 7, 9, 3, 5, 1] sort(reverse = True), sorted(reverse = True) 와 reverse(), reversed() 차이 ⭐️ (reverse = True) 옵션을 사용한 sort와 sorted는 오름차순으로 정렬 후 내림차순으로 정렬해 주는 것이다. ⭐️ reverse()와 reversed()는 정렬 과정 없이 바로 배열을 반대로 뒤집는 것이다.","link":"/2022/02/08/Python/%EC%9E%90%EC%97%B0%EC%88%98%EB%92%A4%EC%A7%91%EC%96%B4%EB%B0%B0%EC%97%B4%EB%A1%9C%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"Python) 최대공약수와 최소공배수","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-09 문제 풀이최대공약수와 최소공배수를 구하는 문제였다. min과 max를 이용하여 입력 받는 수 n, m을 a와 b에 넣어주었다. 123# n이 2, m이 5일 때a, b = min(n, m), max(n, m)# a = 2, b = 5 while문을 사용하여 그 안에 코드를 반복해주었다. r은 최소 값과 최대 값을 나눠주고 그 값을 b에 대입한다. 여기서 b가 0이 되면 while문을 빠져 나온다. 12345# n이 2, m이 5일 때while b != 0 : r = a % b # 2 -&gt; 1 -&gt; 0 a = b # 5 -&gt; 2 -&gt; 1 b = r # 2 -&gt; 1 -&gt; 0 최대공약수와 최소공배수를 리턴한다. 123# n이 2, m이 5일 때return [a, n*m//a] # [1, 10] 전체 코드12345678def solution(n, m): a, b = min(n, m), max(n, m) while b != 0 : r = a % b a = b b = r return [a, n*m//a] 다른 사람의 풀이a, b = b, t 이렇게 한번에 쓸 수도 있다. 123456789def solution(n, m): a, b = max(n, m), min(n, m) t = 1 while t &gt; 0: t = a % b a, b = b, t answer = [a, int(n*m/a)] return answer","link":"/2022/02/09/Python/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/"},{"title":"Python) 나머지가 1이 되는 수 찾기","text":"난이도 : Level 1유형 : 월간 코드 챌린지 시즌3카테고리 : 프로그래머스날짜 : 2022-02-09 수도 코드 작성해보기 👉🏻 n과 x를 나눈 나머지가 1이 되는 값을 return한다.👉🏻 가장 작은 자연수를 찾는 것이기 때문에 min을 이용해도 될 듯 하다.👉🏻 min을 이용하려면 배열이 필요하기 때문에 리스트로 만들어준다. 문제 풀이 처음 생각한 코드 1234def solution(n): for x in range(1, n+1) : # 12345678910 if n % x == 1 : # n과 x를 나눈 나머지가 1이 되는 값 return x # return한다. 수도 코드에 적은 것과 같이 min을 사용하여 작성한 코드 12def solution(n): return min([x for x in range(1,n+1) if n%x==1]) ⭐️ 간단한 문제라도 수도 코드를 적는 연습을 하니, 다양한 방법으로 코드를 짜볼 수 있었다.","link":"/2022/02/09/Python/%EB%82%98%EB%A8%B8%EC%A7%80%EA%B0%801%EC%9D%B4%EB%90%98%EB%8A%94%EC%88%98%EC%B0%BE%EA%B8%B0/"},{"title":"Python) 숫자 문자열과 영단어","text":"난이도 : Level 1유형 : 2021 카카오 채용연계형 인턴십카테고리 : 프로그래머스날짜 : 2022-02-09 문제 풀이 딕셔너리를 이용하여 영단어와 숫자를 매칭시켜주었다. 1dict = {'zero':'0','one':'1','two':'2','three':'3','four':'4','five':'5','six':'6','seven':'7','eight':'8','nine':'9'} 딕셔너리에 있는 key와 value 쌍을 조회하며 해당하는 key가 존재할 경우 value로 치환한다. 12for key, value in dict.items() : answer = answer.replace(key, value) 문자열인 상태를 정수형으로 바꿔주기 위해 int로 감싸 리턴한다. 1return int(answer) 전체 코드1234567def solution(s): answer = '' dict = {'zero':'0','one':'1','two':'2','three':'3','four':'4','five':'5','six':'6','seven':'7','eight':'8','nine':'9'} answer = s for key, value in dict.items() : answer = answer.replace(key, value) return int(answer)","link":"/2022/02/09/Python/%EC%88%AB%EC%9E%90%EB%AC%B8%EC%9E%90%EC%97%B4%EA%B3%BC%EC%98%81%EB%8B%A8%EC%96%B4/"},{"title":"Python) 2309번 일곱난쟁이","text":"난이도 : 브론즈2유형 : 브루트포스카테고리 : 백준 온라인 저지날짜 : 2022-02-15 문제 풀이sum(arr) - (arr[i] + arr[j]) == 100이 되면 해당 난쟁이를 새로운 변수로 넣어두고 마지막에 arr에서 제거한다.sum(arr) - (arr[i] + arr[j]) == 100이 되면 반복문을 한번 더 선언하고 해당 난쟁이를 제외하고 출력 후 exit()로 빠져나온다.break문을 사용하게 되면 해당 반복문만 빠져나오고 다시 반복문을 돌기 때문에 주의한다. 전체 코드1234567891011121314n = 9arr = [int(input()) for _ in range(n)]arr.sort() for i in range(n): for j in range(i+1, n): if sum(arr) - (arr[i] + arr[j]) == 100: for k in range(9): if i == k or j == k: continue print(arr[k]) exit() print('\\n'.join(map(str, arr)))","link":"/2022/02/15/Python/%EC%9D%BC%EA%B3%B1%EB%82%9C%EC%9F%81%EC%9D%B4/"},{"title":"Python) 1436번 영화감독 숌","text":"난이도 : 실버5유형 : 브루트포스카테고리 : 백준 온라인 저지날짜 : 2022-02-16 문제 풀이이 문제는 단순히 666이라는 수 앞에 숫자가 하나씩 커지면 되는 문제가 아니었다. 항상 문제를 잘 확인하자!!! 666만 반복되어야 하기 때문에1.6662.16663.2666..7.66608.6661666만 반복되도록 하라고 했기 때문에 일곱번째에서 6666이 아닌 6660으로 변경되어야 한다. six를 1씩 더해가는 while문을 만들고, 666이 안에 들어있다면 cnt를 1 증가시킨다. 123while True: if '666' in str(six): cnt += 1 cnt가 n과 같다면 six를 출력한다. 123if cnt == n: print(six) break six의 값을 1씩 추가한다. 1six += 1 전체 코드12345678910n = int(input())cnt = 0six = 666while True: if '666' in str(six): cnt += 1 if cnt == n: print(six) break six += 1","link":"/2022/02/16/Python/%EC%98%81%ED%99%94%EA%B0%90%EB%8F%85%EC%88%8C/"},{"title":"Python) 4375번 1","text":"난이도 : 실버3유형 : 수학카테고리 : 백준온라인저지날짜 : 2022-02-17 문제 풀이이 문제는 문제를 이해하는데에 시간이 엄청 걸렸던 것 같다. 이게 무슨말이지..? 했던 문제 중 하나였는데 문제를 풀이해보자면 이렇다. 1로만 이루어진(1, 11, 111, 1111…) n의 배수 중 가장 작은 값의 자리수를 출력하는 문제이다. 그리고 입력에는 여러 개의 테스트 케이스가 주어진다고 했으므로 테스트 케이스가 계속 입력될 수 있도록 코드를 구현해야 한다. 예를 들어 n이 3일 경우 111이 1로만 이루어진 3의 가장 작은 배수이다. 111은 3자리이므로 답은 3이다.n이 7일 경우 111111이 1로만 이루어진 7의 가장 작은 배수이다. 111111은 6자리 이므로 답은 6이다. 쉽게 이야기해서 1, 11, 111...의 수를 반복하면서 n으로 나눴을 때 0으로 딱 떨어지는 수의 자리수를 출력해주면 되는 문제였다. 입력값과 1,11,111을 만들어주는 수 num, 자리수를 카운트해주는 count 변수를 받는다. 123n = int(input()) num = 1 count = 1 while문을 사용하여 num이 1, 11, 111, 1111 …이 되도록 무한반복 시켜준다. 그리고 num의 자리수를 알 수 있도록 하기위해 count를 +1 해주며 반복시켜준다. 123while True : num = (num*10)+1 # 1,11,111 ... count+=1 만약 num % n == 0 이라면 나누어 떨어진 것이기 때문에 break로 반복문을 탈출한다. 1if num%n==0 : break 문제에서 입력 탈출조건을 제공하지 않기 때문에 EOF(End Of File) 예외처리를 try,catch문으로 작성한다. 12345try :. . # 중간 코드.except EOFError : break 전체 코드12345678910111213while True : try : n = int(input()) num = 1 count = 1 while True : if num%n==0 : break num = (num*10)+1 count+=1 print(count) except EOFError : break","link":"/2022/02/17/Python/1/"},{"title":"회고) MakeUs 8기 회고 및 후기","text":"MakeUs 8기 - 1차 서류라이징 캠프 1기를 수료하면 수료 혜택을 받을 수 있는데, 그 중 하나는 MakeUs 서류 통과 혜택이다!!아무리 서류를 통과시켜주더라도 면접을 위해 서류를 잘 쓰긴 해야겠지만, 그래도 1차를 통과시켜준다니! 행복하게 서류를 작성하여 제출하였다. 서류는 노션을 이용하여 지금까지 했던 포트폴리오를 정리했고, 그 안에 자소서도 첨부하여 넣었다. 자소서 문항은 따로 정해져있지 않았기 때문에 메이커스 지원동기, 개발하면서 어려웠던 점과 해결방법 등을 적어서 제출했다. ⭐️ 서류 합격 ⭐️ MakeUs 8기 - 2차 면접면접 시간은 오후 6시 40분이고, 2:1(면접관 2, 면접자 1)로 면접을 진행했다.긴장을 많이하는 타입이라 걱정이 많았지만, 면접관님들께서 분위기를 편하게 해주신 덕분에 편안하게 면접을 진행할 수 있었다. 면접 질문은 서류에 적어놓은 자소서를 기준으로 질문해주셔서 경험을 바탕으로 편안하게 말할 수 있었다. 또 면접 시간도 그리 길지 않아서 긴장러인 나에게는 너무너무 좋았다. 면접 질문에 관한 기억이 가물가물하지만 대충 이런걸 물어봤던 것 같다. 1234자기소개 + 지원동기 지금까지 협업을 하면서 어려웠던 점과 해결방법개발을 하면서 기술적으로 어려웠던 점과 해결방법을 자세하게 위에 질문들 외에 한 두개 정도 더 질문 하셨던 것 같은데 잘 기억이 안난다.. ㅠㅠ 마지막으로 메이커스에 관련하여 궁금한 점이나 질문이 있냐고 물어보셨는데, 이 때 질문을 세개 정도 했던 것 같다.메이커스에 지원할 때 후기나 글들을 많이 찾아봤었는데, 그 중에 궁금했던 것들을 위주로 질문드렸더니 면접관님들께서 좋아해주셨던 기억이 난다.메이커스에 관심이 많은 것 같다고 하시면서 웃어주셨는데, 지금까지 본 면접 중에 가장 기분좋은 면접이었다. ⭐️ 면접 합격 ⭐️ MakeUs 8기 시작!!21.09.11 ~ 21.12.18까지 진행되는 커리큘럼은 이러하다. 팀 빌딩 전내가 느낀 바로는 팀 빌딩 전까지 개발자는 딱히 할 게 없는 단계였다. 주차별 세션에 잘 참여하면서, 기획이나 디자인을 발표해 주실 때 어떤 곳에 들어가고 싶은지 정도(?)를 생각해 놓으면 좋은 것 같다. 팀 빌딩 전까지는 각 파트 별로 다양한 활동을 진행하게 되는데, iOS 파트는 개발에 들어가기 전 활용하고 싶은 스킬이나, 배우고 싶은 내용들을 정해서 각자 공부하고 발표하면서 공유하는 활동을 했었다. 팀빌딩 과정을 알려드리자면, 개발자 팀 빌딩 전에 기획자와 디자이너 먼저 팀 빌딩을 진행한다.그렇게 팀이 정해지면 팀명, 기획, 디자인이 나오게된다. 어느정도 완성된 기획과 디자인을 발표해주시면, 개발자는 원하는 팀의 순위를 매기고 기획자,디자이너 분들도 원하는 개발자의 순위를 매겨 팀빌딩을 진행하는 형식이었다. 그리고 이건 8기에서만 그랬던건진 모르겠지만, 하나 팁을 주자면.. 팀 빌딩 때 까지 가만히 있으면 안된다.원하는 곳을 들어가고 싶다면.. 미리 미리 움직이는 것이 좋은 것 같다. 예를들어, 기획자분께 그 기획에 내가 얼마나 관심이 있는지를 표현하는 디엠을 보낸다던지 등. 나는 잘 안됐지만 이 글을 보는 다른 메이커스 활동자들은 성공하셨으면해서 쓰는 팁이다..!! 팀 빌딩 후팀 빌딩이 되고나면, 해당 팀에서 모든 것이 이루어진다.디자인이 나오면 개발을 진행하고, 중간중간 개발 진행상황을 세션 발표를 통해 상황을 공유한다.그리고 런칭데이라는 기간 내에 런칭을 목표로 모두가 열심히 개발을 하게된다. 개발자들은 이때가 진짜 빡세다.. 나는 팔보채라는 팀에 iOS 개발자로 합류하게 되었다. 우피치 Wupitch운동하고 싶은 여성들을 위한 여성 스포츠 커뮤니티 플랫폼 대망의 데모데이!! 데모데이는 게더타운이 아닌, 실제로 부스를 꾸미고 사람들에게 우리의 서비스를 소개해 줄 수 있어서 너~무 좋았다. 처음에는 실제로하나 비대면으로 하나 뭐가 다를까? 라고 생각했지만, 막상 해보니 비대면으로 했다면 굉장히 아쉬웠겠다라는 생각이 든다. 나의 첫 데모데이는 성공적이다. 동아리 활동을 하면서 모두가 힘들게 노력했기 때문에 데모데이에서 더 빛을 발한게 아닌가라는 생각이 든다. 모두가 대단하게 느껴지면서 정말 감동이 찡하게 왔던 것 같다. 수료 동아리 활동이 끝이났다. 코로나19로 인해 세션은 항상 게더타운으로 진행했지만, 그래도 두어번 정도는 만나서 세션을 진행할 수 있어서 좋았다. 3개월동안 우여곡절이 정말 많았지만, 꾸준히 개발할 수 있는 힘도 기를 수 있었고, 한 팀의 구성원이 되어 다같이 으쌰으쌰해가며 개발하는 경험을 해볼 수 있어서 더 값진 활동이 된 것 같다. 이런저런 과정속에서 정말 많이 성장한 것 같다. 또한 다양한 파트 사람들을 만나서 좋았고, 열정 가득한 사람들 덕분에 나 또한 열정적으로 동아리 활동에 임할 수 있었던 것 같다. Central MakeUs Challenge를 하고싶다면협업 경험이 있는 사람나를 면접봐주셨던 면접관님께서 얘기해주셨는데, 아무래도 삼개월 안에 앱을 런칭해야하는 동아리다보니 서버와의 협업 경험이 있는 분들이 뽑힐 확률이 높다고 말씀해주셨다. 서버와의 협업 경험이 있다면 그 경험을 잘 어필하면 될 것 같다! 단기간에 앱을 만들어 런칭해보고 싶은 사람단기간에 정말 앱이 하나가 나온다. 불가능하지 않을까? 했지만 가능했다. 또한 런칭도 해볼 수 있기 때문에 런칭 경험도 가져갈 수 있다.개인적으로 아쉬운 점이 있다면, 이 동아리의 성격상 단기간에 런칭까지 진행해야 하기 때문에 기획의 사이즈가 크다면 개발할 때 힘들 수도 있다. 협업 경험한 팀에 각 파트가 모두 있기 때문에, 제대로된 협업을 경험해 볼 수 있었다. PM과의 협업은 처음이었지만 기획을 개발자의 입장에서 말씀드릴 수 있었고, 함께 조율해나갈 수 있다는 것을 배웠다. 기획을 더 좋은 방향으로 서로의 입장에서 얘기하며 만들다보니, 내가 개발하는 앱에 대한 애정도 또한 상승했던 것 같다. 디자이너와의 협업은 경험이 있었지만, 협업 툴이 처음 사용해보는 툴이다 보니 질문을 통해 감을 익혔던 것 같다.또한 어떤 디자인이 사용자가 더 편하게 사용할 수 있는 디자인일까에 대해 사용자의 입장으로, 개발자의 입장으로 디자이너 분과 많은 얘기를 나눠볼 수 있었다. 디자이너분과의 소통을 통해 개발자도 사용자의 ux를 고려하며 개발을 하면 더 좋은 개발자가 될 수 있겠다라는 점도 배울 수 있었다. 서버 개발자와는 api 관련하여 소통을 굉장히 자주 했다. 서버가 나오기 전에 먼저 뷰를 만들어야 하는 상황이기 때문에, 이 뷰에서는 이런 api가 필요하다라는 것을 사전에 말씀드리고 진행을 했던 것 같다. 그러다보니 미리 뷰 작업을 하고 서버가 나와도 바로 적용시킬 수 있어 개발의 능률이 올라갈 수 있었다. 이번 동아리를 통해 서버 개발자분께 클라이언트로서 어떤식으로 요청드리면 되는지, 어떤식으로 함께 소통해 나갈 수 있는지에 대해 배웠던 것 같다. 단기간이지만 많은 것을 배우고 깨달았던 나의 첫 동아리 활동이었다.","link":"/2021/12/18/%ED%9A%8C%EA%B3%A0/CentralMakeUsChallenge/"},{"title":"Python) 1697번 숨바꼭질","text":"난이도 : 실버1유형 : BFS카테고리 : 백준 온라인 저지날짜 : 2022-02-18 문제 풀이 점 N의 범위 (0 ≤ N ≤ 100,000) 123visited는 크기가 100001인 배열visited = [0]*100001 # 방법1visited = [0 for i in range(100001)] # 방법2 소요 시간 카운트하는 방법 1visited[i] = visited[v] + 1 점 N 방문처리할 필요 없음 1234N을 다시 방문하는 경로는 어차피 최단경로가 아님def bfs(N, K, visited): queue = deque([N]) visited[N] = 1 # 불필요 전체 코드123456789101112131415161718import sysfrom collections import deque N, K = map(int, sys.stdin.readline().split(' '))visit = [0 for i in range(100001)] def bfs(N, K, visited): queue = deque([N]) while queue: v = queue.popleft() if v == K: return visit[K]; for i in (v-1, v+1, v*2): if (-1&lt;i&lt;100001) and not visit[i]: queue.append(i) visit[i] = visit[v] + 1 print(bfs(N, K, visit))","link":"/2022/02/18/Python/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/"},{"title":"Python) 정수 제곱근 판별","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-19 문제 풀이제곱을 구하는 ** 를 이용하여 푸는 문제였다. 문제에 답이 다 나와있어 어렵지 않게 풀 수 있었다. n이 양의 정수 number의 제곱이라면 1number = n ** 0.5 number+1의 제곱을 리턴하고 1return (number+1)**2 x의 제곱이 아니라면 -1을 리턴해라 1return -1 전체 코드123456def solution(n): number = n ** 0.5 if number == int(number) : return (number+1)**2 else : return -1","link":"/2022/02/19/Python/%EC%A0%95%EC%88%98%EC%A0%9C%EA%B3%B1%EA%B7%BC%ED%8C%90%EB%B3%84/"},{"title":"Python) 하샤드 수","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-20 문제 풀이하샤드 수를 구하는 문제이다.예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수이다.x가 하샤드 수 일때는 true, 아닐 때는 false를 리턴하면 된다. x의 수를 첫번째 자리 수와 두번째 자리 수로 나누기 위해 str을 사용하여 문자열로 쪼개준다.그런다음 for문을 사용하여 두개의 수를 더해 answer에 넣어준다. 그러면 두 자릿수의 합을 구할 수 있다. 12for i in str(x): answer += int(i) x가 answer로 나누어 떨어지면 하샤드 수이기 때문에 True를 리턴한다. 12if x % answer == 0 : return True 그렇지 않으면 False를 리턴한다. 12else : return False 전체 코드123456789def solution(x): answer = 0 for i in str(x): answer += int(i) if x % answer == 0 : return True else : return False","link":"/2022/02/20/Python/%ED%95%98%EC%83%A4%EB%93%9C%EC%88%98/"},{"title":"Python) 콜라츠 추측","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-21 문제 풀이주어진 수가 1이 될 때까지 작업을 반복하면, 모든 수를 1로 만들 수 있는 콜라츠 추측을 구하는 문제이다.예를 들어 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 된다.위 작업에서 몇 번이나 반복해야하는지 반환하는 함수를 구하되, 작업을 500번을 반복해도 1이 되지 않는다면 –1을 리턴한다. 먼저 이 문제에 필요한 변수들을 생각해본다. 12num # 처음 입력 받는 수 ctn # 몇 번이나 반복하는지 세는 변수 입력받는 수 num이 1이 되면 멈출 수 있도록 while문으로 반복한다.그런다음 짝수일 때 num을 2로 나눠준다. 123while num != 1: if num % 2 == 0 : num //= 2 홀수일 때 num에 3을 곱하고 1을 더해준다. 12else : num = (num * 3) + 1 반복한 횟수 ctn이 500번을 반복해도 1이 되지 않는다면 –1을 리턴한다. 123if answer == 500 : answer = -1 break 전체 코드123456789101112def solution(num): ctn = 0 while num != 1: if num % 2 == 0 : num //= 2 else : num = (num * 3) + 1 ctn += 1 if ctn == 500 : ctn = -1 break return ctn","link":"/2022/02/21/Python/%EC%BD%9C%EB%9D%BC%EC%B8%A0%EC%B6%94%EC%B8%A1/"},{"title":"Python) 소수 찾기","text":"난이도 : Level 2유형 : 완전탐색카테고리 : 프로그래머스날짜 : 2022-02-22 문제 풀이 사용되어야 할 변수 123numbers # 입력받는 수answer # 소수의 갯수 nums # 순열조합을 합쳐주기 위해 생성한 변수 입력받은 문자열 numbers의 한자리 수부터 len(numbers)의 수까지 순열(permutations)로 만들어준다. 12for i in range(1, len(numbers)+1) : # 1부터 문자열 num의 +1까지의 수 반복 for j in permutations(numbers, i) : # 입력받은 문자열을 순열 조합으로 변경 순열로 만들어 준 수를 join 연산자를 사용하여 합쳐준다. 예) (‘1’, ‘7’) -&gt; 17 1nums = int(''.join(j)) 각각의 수가 소수인지 검사하여, 소수면 리스트 answer에 추가해준다. 123456for k in range(2, nums) : # 소수 검사 if nums % k == 0 : # 나누어 떨어지면 소수 X breakelse : # 나누어 떨어지지 않으면 if nums not in answer and nums != 0 and nums != 1 : # 소수 O answer.append(nums) # answer에 nums 추가 리스트 answer의 갯수를 리턴한다. 1return len(answer) 전체 코드12345678910111213from itertools import permutationsdef solution(numbers): answer = [] for i in range(1, len(numbers)+1) : for j in permutations(numbers, i) : nums = int(''.join(j)) for k in range(2, nums) : if nums % k == 0 : break else : if nums not in answer and nums != 0 and nums != 1 : answer.append(nums) return len(answer)","link":"/2022/02/22/Python/%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0/"},{"title":"Python) 피보나치 수","text":"난이도 : Level 2유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-23 문제 풀이배열을 사용하여 코드를 작성한다.배열 안에 추가될 때는 %1234567 계산까지 한 후에 추가한다. 전체 코드123456def solution(n): answer = [0,1] # F(0)=0, F(1)=1 for i in range(2,n+1): # F(n) = (F(n-1) + F(n-2)) % 1234567 answer.append((answer[i-1] + answer[i-2]) % 1234567) return answer[-1]","link":"/2022/02/23/Python/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%EC%88%98/"},{"title":"Python) 문자열 압축","text":"난이도 : Level 2유형 : 2020 KAKAO BLIND RECRUITMENT카테고리 : 프로그래머스날짜 : 2022-02-24 문제 풀이처음에는 하나씩 다음부터 두 개씩, 세 개씩 쪼개는 형식으로 for문을 돌린다. 그 중 길이가 제일 작은 값은 return 한다. 전체 코드1234567891011121314151617181920212223242526def solution(s): answer = [] if len(s) == 1: return 1 for i in range(1, (len(s)//2)+1): b = '' cnt = 1 tmp = s[:i] for j in range(i, len(s), i): if tmp == s[j:i+j]: cnt+=1 else: if cnt != 1: b = b + str(cnt) + tmp else: b = b + tmp tmp = s[j:j+i] cnt = 1 if cnt != 1: b = b + str(cnt) + tmp else: b = b + tmp answer.append(len(b)) return min(answer)","link":"/2022/02/24/Python/%EB%AC%B8%EC%9E%90%EC%97%B4%EC%95%95%EC%B6%95/"},{"title":"Python) 완주하지 못한 선수","text":"난이도 : Level 1유형 : 해시카테고리 : 프로그래머스날짜 : 2022-02-25 문제 풀이해시를 사용해서 문제를 풀었다.participant가 completion보다 딱 한 명 더 많기 때문에, 모든 participant의 요소들의 해시값을 다 더해서, 모든 completion의 요소들의 해시값을 빼주면 완주하지 못한 선수의 해시값만 남는다. 마지막 남은 해시 값은 dictionary를 사용한다. key를 해시 값으로, value를 이름으로 설정해주면 마지막 남은 해시 값을 통해 dictionary에 접근하여 이름을 찾는다. 전체 코드123456789def solution(participant, completion): d = dict() hashValue = 0 for p in participant: d[hash(p)] = p hashValue += hash(p) for c in completion: hashValue -= hash(c) return d[hashValue]","link":"/2022/02/25/Python/%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80%EB%AA%BB%ED%95%9C%EC%84%A0%EC%88%98/"},{"title":"Python) 짝지어 제거하기","text":"난이도 : Level 2유형 : 2017 팁스타운카테고리 : 프로그래머스날짜 : 2022-02-26 문제 풀이stack을 사용해서 문제를 풀었다.stack이 비어있다면 push를 해주고, stack 마지막 값과 s[i]가 같다면 pop, stack 마지막 값과 s[i]가 다르면 push해준다.마지막으로 stack이 비어있지 않다면 0을 리턴해주고 stack이 비어있다면 1을 리턴한다. 전체 코드12345678910111213def solution(s): stack = [] for i in range(len(s)): if not stack: stack.append(s[i]) else: if s[i] == stack[-1]: stack.pop() else: stack.append(s[i]) if stack : return 0 else : return 1","link":"/2022/02/26/Python/%EC%A7%9D%EC%A7%80%EC%96%B4%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/"},{"title":"Python) 이상한 문자 만들기","text":"난이도 : Level 1유형 : 연습문제카테고리 : 프로그래머스날짜 : 2022-02-27 문제 풀이공백을 기준으로 문자를 나눠준다.그리고 글자 인덱스에 맞게 2로 나눈경우 나머지가 0이면 대문자로, 아니면 소문자로 변경한다. 전체 코드123456789101112131415def solution(s): answer = [] s = s.split(' ') for i in range(len(s)): result = '' for j in range(len(s[i])): if j % 2 == 0: result += s[i][j].upper() else: result += s[i][j].lower() answer.append(result) return ' '.join(answer)","link":"/2022/02/27/Python/%EC%9D%B4%EC%83%81%ED%95%9C%EB%AC%B8%EC%9E%90%EB%A7%8C%EB%93%A4%EA%B8%B0/"},{"title":"Python) H-Index","text":"난이도 : Level 2유형 : 정렬카테고리 : 프로그래머스날짜 : 2022-02-28 문제 풀이if citations[i] &gt;= citations_len-i는 주어진 h번 이상 인용된 논문이 h편 이상이라는 조건을 그대로 풀어쓴 것이다.citations[i]는 i번 논문이 인용된 횟수이고 citations_len-i는 인용된 논문의 개수를 최댓값부터 하나씩 줄여나간 것이다. (최댓값을 찾아야 하므로 가장 큰 값부터 시작)그리고 리스트는 오름차순 정렬된 상태이므로 i번째 이후는 모두 i번째보다 큰 값을 가질 것이다. 전체 코드12345678def solution(citations): citations.sort() citations_len = len(citations) for i in range(citations_len): if citations[i] &gt;= citations_len-i: return citations_len-i return 0","link":"/2022/02/28/Python/Hindex/"}],"tags":[{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Struct","slug":"Struct","link":"/tags/Struct/"},{"name":"Boostcourse","slug":"Boostcourse","link":"/tags/Boostcourse/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"},{"name":"Architecture Pattern","slug":"Architecture-Pattern","link":"/tags/Architecture-Pattern/"},{"name":"MVP","slug":"MVP","link":"/tags/MVP/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"Optional","slug":"Optional","link":"/tags/Optional/"},{"name":"Instance","slug":"Instance","link":"/tags/Instance/"},{"name":"Type","slug":"Type","link":"/tags/Type/"},{"name":"Method","slug":"Method","link":"/tags/Method/"},{"name":"Singleton","slug":"Singleton","link":"/tags/Singleton/"},{"name":"Strategy","slug":"Strategy","link":"/tags/Strategy/"},{"name":"RisingCamp","slug":"RisingCamp","link":"/tags/RisingCamp/"},{"name":"RisingCamp 1기","slug":"RisingCamp-1기","link":"/tags/RisingCamp-1%EA%B8%B0/"},{"name":"회고","slug":"회고","link":"/tags/%ED%9A%8C%EA%B3%A0/"},{"name":"CMC 8기","slug":"CMC-8기","link":"/tags/CMC-8%EA%B8%B0/"},{"name":"후기","slug":"후기","link":"/tags/%ED%9B%84%EA%B8%B0/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Programmers","slug":"Programmers","link":"/tags/Programmers/"},{"name":"BaekjoonOnlineJudge","slug":"BaekjoonOnlineJudge","link":"/tags/BaekjoonOnlineJudge/"},{"name":"4375번","slug":"4375번","link":"/tags/4375%EB%B2%88/"},{"name":"1","slug":"1","link":"/tags/1/"},{"name":"1436번","slug":"1436번","link":"/tags/1436%EB%B2%88/"},{"name":"영화감독 숌","slug":"영화감독-숌","link":"/tags/%EC%98%81%ED%99%94%EA%B0%90%EB%8F%85-%EC%88%8C/"},{"name":"2309번","slug":"2309번","link":"/tags/2309%EB%B2%88/"},{"name":"일곱난쟁이","slug":"일곱난쟁이","link":"/tags/%EC%9D%BC%EA%B3%B1%EB%82%9C%EC%9F%81%EC%9D%B4/"},{"name":"Central MakeUs Challenge","slug":"Central-MakeUs-Challenge","link":"/tags/Central-MakeUs-Challenge/"},{"name":"MakeUs 8기","slug":"MakeUs-8기","link":"/tags/MakeUs-8%EA%B8%B0/"},{"name":"1697번","slug":"1697번","link":"/tags/1697%EB%B2%88/"},{"name":"숨바꼭질","slug":"숨바꼭질","link":"/tags/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/"}],"categories":[{"name":"Swift","slug":"Swift","link":"/categories/Swift/"},{"name":"Architecture","slug":"Architecture","link":"/categories/Architecture/"},{"name":"회고","slug":"회고","link":"/categories/%ED%9A%8C%EA%B3%A0/"},{"name":"Python","slug":"Python","link":"/categories/Python/"}]}