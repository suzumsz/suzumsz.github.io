{"pages":[],"posts":[{"title":"iOS) Class가 무엇이고 어떻게 사용하는지 설명하시오.","text":"Class란? 클래스는 참조(reference)타입이다. 타입 이름은 대문자 카멜케이스를 사용하여 정의한다.\u001c Swift의 클래스는 다중 상속이 되지 않는다. Class 문법 ‘class’ 키워드를 사용한다. 123class (대문자)이름 { /* 구현부 */}\u001c 프로퍼티 및 메서드 구현 1234567891011121314151617181920212223242526class Sample { // 가변 프로퍼티 var mutableProperty : Int = 100 // 불변 프로퍼티 let immutableProperty : Int = 100 // 타입 프로퍼티 static var typeProperty : Int = 100 // 인스턴스 메서드 func instanceMethod() { print(&quot;instance Method&quot;) } // 타입 메서드 // 상속시 재정의 불가 타입 메서드 - static static func typeMethod() { print(&quot;type Method - static&quot;) } // 상속시 재정의 가능 타입 메서드 - class class func classMethod() { print(&quot;type Method - class&quot;) }} 클래스 사용 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 인스턴스 생성 - 참조정보 수정 가능var mutableReference : Sample = Sample()mutableReference.mutableProperty = 200print(&quot;가변 인스턴스의 가변 프로퍼티 값은? &quot;,mutableReference.mutableProperty)// ----- 출력값// 가변 인스턴스의 가변 프로퍼티 값은? 200// 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다.// 컴파일 오류 발생// mutableReference.immutableProperty = 200// 인스턴스 생성 - 참조정보 수정 불가let immutableRefernce : Sample = Sample()// 클래스의 인스턴스는 참조타입이므로 let으로 선언되었더라도 인스턴스 프로퍼티의 값 변경이 가능하다.immutableRefernce.mutableProperty = 200print(&quot;불변 인스턴스의 가변 프로퍼티 값은?&quot;,immutableRefernce.mutableProperty)// ----- 출력값// 불변 인스턴스의 가변 프로퍼티 값은? 200// 다만 참조정보를 변경할 수는 없다.// 컴파일 오류 발생// immutableRefernce = mutableReference// 참조 타입이더라도 불변 인스턴스는// 인스턴스 생성 후에 수정할 수 없다.// 컴파일 오류 발생// immutableRefernce.immutableProperty = 200// 타입 프로퍼티 및 메서드Sample.typeProperty = 300print(&quot;타입 프로퍼티 값은?&quot;,Sample.typeProperty)// ----- 출력값// 타입 프로퍼티 값은? 300Sample.typeMethod()// ----- 출력값// type Method - static// 인스턴스에서는 타입 프로퍼티나 타입 메서드를 사용할 수 없다.// 컴파일 오류 발생// mutableReference.typeProperty = 200// mutableReference.typeMethod() 예제) 학생 클래스 만들어보기123456789101112131415161718192021222324252627282930313233343536373839class Student { // 가변 프로퍼티 var name : String = &quot;unknown&quot; // 키워드도 `로 묶어주면 이름으로 사용할 수 있다. var `class`: String = &quot;Swift&quot; // 타입 메서드 class func selfIntroduce() { print(&quot;학생 타입입니다.&quot;) } // 인스턴스 메서드 // self는 인스턴스 자신을 지칭하며, 몇몇 경우를 제외하고 사용은 선택사항이다. func selfIntroduce() { print(&quot;저는 \\(self.class)반 \\(name)입니다&quot;) }}// 타입 메서드 사용Student.selfIntroduce()// ----- 출력값// 학생 타입입니다.// 가변 인스턴스 생성var flora : Student = Student()flora.name = &quot;플로라&quot;flora.class = &quot;스위프트&quot;flora.selfIntroduce()// ----- 출력값// 저는 스위프트반 플로라입니다.// 불변 인스턴스 생성let sujeong : Student = Student()sujeong.name = &quot;수정&quot;sujeong.class = &quot;아이오에스&quot;sujeong.selfIntroduce()// ----- 출력값// 저는 아이오에스반 수정입니다. 정리 클래스에서 정의한 프로퍼티를 사용하고 싶다면 인스턴스 생성 후 프로퍼티를 사용할 수 있다. 그 중 타입 프로퍼티나 타입 메서드는 인스턴스 생성 없이 클래스 이름에 대입하여 바로 사용할 수 있다. 인스턴스 메서드는 생성한 인스턴스와 함께 사용할 수 있다. (타입 메서드와는 다름) 생성한 인스턴스에서는 타입 프로퍼티나 타입 메서드를 사용할 수 없다. 가변 인스턴스 생성 시 가변 프로퍼티는 수정이 가능하지만, 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다. 불변 인스턴스 생성 시 클래스의 인스턴스는 참조타입이므로 가변 프로퍼티 수정이 가능하지만 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다. 불변 인스턴스를 가변 인스턴스로 참조정보를 변경할 수 없다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 클래스","link":"/2021/09/24/Class/"},{"title":"iOS) Struct가 무엇이고 어떻게 사용하는지 설명하시오.","text":"Struct란? Swift 대부분 타입은 구조체로 이루어져 있다. 구조체는 값(value)타입이다. 타입 이름은 대문자 카멜케이스를 사용하여 정의한다.\u001c Struct 문법 ‘struct’ 키워드로 구조체를 정의한다. 123struct (대문자)이름 { /* 구현부 */}\u001c 구조체 프로퍼티 및 메서드 구현 1234567891011121314151617struct Sample { // 가변 프로퍼티(값 변경 가능) var mutableProperty:Int = 100 // 불변 프로퍼티(값 변경 불가능\u001d) let immutableProperty:Int = 100 // 타입 프로퍼티(static 키워드 사용: 타입 자체가 사용하는 프로퍼티) static var typeProperty:Int = 100 // 인스턴스 메서드(인스턴스가 사용하는 메서드) func instanceMethod() { print(&quot;instance method&quot;) } // 타입 메서드(static 키워드 사용: 타입 자체가 사용하는 메서드) static func typeMethod() { print(&quot;type method&quot;) }}\u001c 구조체 사용 123456789101112131415161718192021222324252627282930313233343536373839404142// 가변 인스턴스 생성var mutable: Sample = Sample()mutable.mutableProperty = 200print(&quot;변경된 가변 프로퍼티 값은? &quot;,mutable.mutableProperty)// ----- 출력값// 변경된 가변 프로퍼티 값은? 200// 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다.// 컴파일 오류 발생// mutable.immutableProperty = 200// 불변 인스턴스 생성let immutable: Sample = Sample()// 불변 인스턴스는 아무리 가변 프로퍼티라도// 인스턴스 생성 후에 수정할 수 없다.// 컴파일 오류 발생// immutable.mutableProperty = 200// immutable.immutableProperty = 200// 타입 프로퍼티 및 메서드// 타입 프로퍼티는 인스턴스를 생성하지 않고 바로 사용할 수 있다.Sample.typeProperty = 300print(&quot;타입 프로퍼티의 변경된 값은 &quot;,Sample.typeProperty)// ----- 출력값// 타입 프로퍼티의 변경된 값은 300Sample.typeMethod()// ----- 출력값// type method// 인스턴스에서는 타입 프로퍼티나 타입 메서드를// 사용할 수 없다.// 컴파일 오류 발생// mutable.typeProperty = 400// mutable.typeMethod()// 인스턴스 메서드 mutable.instanceMethod()// ----- 출력값// instance method 예제) 학생 구조체 만들어보기1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Student { // 가변 프로퍼티 var name : String = &quot;unknown&quot; // 키워드도 `로 묶어주면 이름으로 사용할 수 있다. var `class`: String = &quot;Swift&quot; // 타입 메서드 static func selfintroduce() { print(&quot;학생 타입 입니다.&quot;) } // 인스턴스 메서드 // self는 인스턴스 자신을 지칭하며, 몇몇 경우를 제외하고 사용은 선택사항 func selfintroduce() { print(&quot;저는 \\(self.class)반 \\(name)입니다.&quot;) } // 타입 메서드 사용 Student.selfintroduce() // ----- 출력값 // 학생 타입 입니다. // 가변 인스턴스 생성 var flora : Student = Student() // 프로퍼티 사용 flora.name = &quot;플로라&quot; flora.class = &quot;스위프트&quot; // 인스턴스 메서드 사용 flora.selfintroduce() // ----- 출력값 // 저는 스위프트반 플로라입니다. // 불변 인스턴스 생성 let sujeong : Student = Student() // 불변 인스턴스이므로 프로퍼티 값 변경 불가 // 컴파일 오류 발생 // sujeong.name = &quot;수정&quot; sujeong.selfintrodeuce() // ----- 출력값 // 저는 Swift반 unknown입니다.} 정리 구조체에서 정의한 프로퍼티를 사용하고 싶다면 인스턴스 생성 후 프로퍼티를 사용할 수 있다. 그 중 타입 프로퍼티나 타입 메서드는 인스턴스 생성 없이 구조체 이름에 대입하여 바로 사용할 수 있다. 인스턴스 메서드는 생성한 인스턴스와 함께 사용할 수 있다. (타입 메서드와는 다름) 가변 인스턴스 생성 시 가변 프로퍼티는 수정이 가능하지만, 불변 프로퍼티는 인스턴스 생성 후 수정할 수 없다. 불변 인스턴스 생성 시 가변 프로퍼티, 불변 프로퍼티 둘 다 인스턴스 생성 후에 수정할 수 없다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 구조체","link":"/2021/09/23/Struct/"},{"title":"iOS) Optional이란 무엇인지 설명하시오.","text":"옵셔널(Optional)이란? 값이 있을수도 있고, 없을수도 있음을 표현 12345let optionalConstant : Int? = nil// 옵셔널이 아닌 상수에 nil값을 할당하려고 하면// 컴파일 오류 발생// let someConstant : Int = nil nil이 할당 될 수 있는지 없는지 표현\u001c 123456789101112// someOptionalParam에는 nil이 할당 될 수 있다.func someFunction(someOptionalParam:Int?) { // ...}// someParam에는 nil이 할당 될 수 없다.func someFunction(someParam:Int) { // ...}someFunction(someOptionalParam:nil)// someFunction(someParam:nil) 옵셔널을 사용하는 이유 명시적 표현 nil의 가능성을 코드만으로 표현 가능 문서/주석 작성 시간 절약\u001c 안전한 사용 전달받은 값이 옵셔널이 아니라면 nil체크를 하지 않고 사용가능 예외 상황을 최소화하는 안전한 코딩 효율적인 코딩 옵셔널 문법과 선언 옵셔널 문법 enum + generics 옵셔널 선언 12345678enum Optional&lt;Wrapped&gt; : ExpressibleByNiliteral { case none // 옵셔널에 값이 없다. case some(Wrapped) // 옵셔널 내외에 값이 있다.}// 옵셔널의 타입let optionalValue : Optional&lt;Int&gt; = nil // 완전한 문법let optionalValue : Int? = nil // 이렇게도 사용 가능 💡 물음표는 띄어쓰지 않는다! 옵셔널 표현! (Implicitly Unwrapped Optional) 암시적 추출 옵셔널 기존 변수처럼 사용 가능 1234567891011121314151617181920212223242526var optionalValue : Int! = 100switch optionalValue { case .none : print(&quot;This Optional variable is nil&quot;) case .some(let value) : print(&quot;Value is \\(value)&quot;)}// ----- 출력값// Value is 100// 기존 변수처럼 사용 가능optionalValue = optionalValue + 1print(optionalValue!)// ----- 출력값// 101// nil 할당 가능optionalValue = nilprint(optionalValue)// ----- 출력값// nil// optionalValue에 nil을 할당해놓은 상태에서 + 1을 해주면// 잘못된 접근으로 인한 런타임 오류 발생// optionalValue = optionalValue + 1 ? (General Optional) 기존 변수처럼 사용 불가 옵셔널과 일반 값은 다른 타입이므로 연산불가 12345678910111213141516171819var optionalValue : Int? = 100switch optionalValue { case .none : print(&quot;This Optional variable is nil&quot;) case .some(let value) : print(&quot;Value is \\(value)&quot;)} // ----- 출력값// Value is 100// nil 할당 가능optionalValue = nilprint(optionalValue)// ----- 출력값// nil// 기존 변수처럼 사용불가 - 옵셔널과 일반 값은 다른 타입이므로 연산불가// optionalValue = optionalValue + 1 옵셔널 추출 옵셔널에 들어있는 값을 사용하기 위해 꺼내오는 것이다. 옵셔널 바인딩 nil 체크 + 안전한 추출 옵셔널 안에 값이 있는지 확인하고, 값이 있으면 값을 꺼내온다. if-let 방식을 사용한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849func printName(_ name : String) { print(name)}var myName : String? = nil// printName은 기본 타입 그리고 myName은 옵셔널 타입으로 // 전달되는 값의 타입이 다르기 때문에 컴파일 오류발생// printName(myName)if let name : String = myName { printName(name)}else { print(&quot;myName == nil&quot;)}// ----- 출력값// myName == nil// name 상수는 if-let 구문 내에서만 사용가능하다.// 상수 사용범위를 벗어났기 때문에 컴파일 오류 발생// printName(name)var yourName : String! = nilif let name : String = yourName { print(name)}else { print(&quot;yourName == nil&quot;)}// ----- 출력값// yourName == nil// 쉼표(,)를 사용하여 한 번에 여러 옵셔널을 바인딩 할 수 있다.// 모든 옵셔널에 값이 있을 때만 동작한다.myName = &quot;sujeong&quot;yourName = nil// yourName이 nil이기 때문에 실행되지 않는다.// if let name = myName, let friend = yourName {// print(&quot;\\(name) and \\(friend)&quot;)// }yourName = &quot;wonseok&quot;if let name = myName, let boyFriend = yourName { print(&quot;\\(name) and \\(boyFriend)&quot;)}// ----- 출력값// sujeong and wonseok 강제추출 옵셔널에 값이 들어있는지 아닌지 확인하지 않고, 강제로 값을 꺼내는 방식이다. 만약 값이 없을경우(nil) 런타임 오류가 발생하기 때문에 추천하지 않는다. 1234567891011121314151617181920212223func printName(_ name: String) { print(name)}// 옵셔널의 값을 강제로 꺼내와서 전달하고자 한다면, // myName의 옵셔널 물음표가 벗겨지면서 안에 있던 값 sujeong이 강제로 추출되어 (myName!)에 들어온다. // 그러므로 옵셔널 타입이 아닌 스트링 타입 printName으로 값을 넘겨줄 수 있는 것이다.var myName : String? = &quot;sujeong&quot;var yourName : String! = nilprintName(myName!)// ----- 출력값// sujeongmyName = nil// 강제추출시 값이 없으므로 런타임 오류 발생// print(myName!)yourName = nil// nil 값이 전달되기 때문에 런타임 오류 발생// printName(yourName) 옵셔널 체이닝 옵셔널의 내부의 내부의 내부로 옵셔널이 연결되어 있을 때 유용하게 활용할 수 있다. 매번 nil 확인을 하지 않고 최종적으로 원하는 값이 있는지 없는지 확인할 수 있다. 예제12345678910111213141516171819202122232425262728293031// 사람 클래스class Person { var name : String var job : String? var home : Apartment? init(name : String) { self.name = name }}// 사람이 사는 집 클래스class Apartment { var buildingNumber : String var roomNumber : String var `guard` : Person? var owner : Person? init(dong : String, ho : String) { buildingNumber = dong roomNumber = ho }}// 옵셔널 체이닝 사용let sujeong : Person? = Person(name:&quot;sujeong&quot;)let apart : Apartment? = Apartment(dong:&quot;307&quot;,ho:&quot;1203&quot;)let superman : Person? = Person(name:&quot;superman&quot;)// 옵셔널 체이닝 실행 후 결과값이 nil일 수 있으므로 // 결과 타입도 옵셔널이다. 만약 우리집 경비원 직업이 궁금하다면?1234567891011121314151617181920212223242526272829// 옵셔널 체이닝을 사용하지 않는 경우func guardJob(owner: Person?) { if let owner = owner { if let home = owner.home { if let `guard` = home.guard { if let guardJob = `guard`.job { print(&quot;우리집 경비원의 직업은 \\(guardJob)입니다.&quot;) } else { print(&quot;우리집 경비원은 직업이 없어요.&quot;) } } } }}guardJob(owner: sujeong)// 옵셔널 체이닝을 사용하는 경우func guardJobWithOptionalChaining(owner: Person?) { if let guardJob = owner?.home?.guard?.job { print(&quot;우리집 경비원의 직업은 \\(guardJob)입니다.&quot;) } else { print(&quot;우리집 경비원은 직업이 없어요.&quot;) }}guardJobWithOptionalChaining(owner: sujeong)// ----- 출력값// 우리집 경비원은 직업이 없어요. nil 병합 연산자 ?? 중위 연산자 Optional ?? Value 옵셔널 값이 nil 일 경우, 우측 값을 반환한다. 띄어쓰기에 주의 12345678910111213var guardJob : StringguardJob = sujeong?.home?.guard?.job ?? &quot;슈퍼맨&quot;print(guardJob)// ----- 출력값// 경비원sujeong?.home?.guard?.job = nilguardJob = sujeong?.home?.guard?.job ?? &quot;슈퍼맨&quot;print(guardJob)// ----- 출력값// 슈퍼맨 정리 옵셔널은 값이 있을수도, 없을수도 있음을 표현한다. 옵셔널이 아닌 상수에 nil값을 할당하려고 하면 컴파일 오류가 발생한다. 옵셔널은 열거형(enum)과 general의 합작품이라고 볼 수 있다. !(Implicitly Unwrapped Optional)은 기존 변수처럼 사용이 가능하다. ?(General Optional)은 옵셔널과 일반 값은 다른 타입이므로 기존 변수처럼 사용이 불가하다. 옵셔널 바인딩은 옵셔널 안에 값이 있는지 확인하고, 값이 있으면 값을 꺼내오며 if-let 방식을 사용한다. 옵셔널 바인딩 시 선언한 상수는 if-let 구문 내에서만 사용할 수 있으며, 상수의 사용 범위를 벗어나면 컴파일 오류가 발생한다. 쉽표(,)를 통해 한번에 여러 옵셔널을 바인딩 할 수 있는데, 모든 옵셔널에 값이 있어야만 동작한다. 강제추출은 옵셔널에 값이 들어있는지 아닌지 확인하지 않고, 강제로 값을 꺼내는 방식이다. 강제추출은 옵셔널로 선언되어 있는 값을 강제로 추출한 후 옵셔널 타입이 아닌 다른 타입으로 값을 넘겨줄 수 있다. 옵셔널 체이닝은 옵셔널의 내부의 내부의 내부로 옵셔널이 연결되어 있을 때 유용하며, 최종적으로 원하는 값이 있는지 없는지를 확인한다. 옵셔널 체이닝 시, if-let 안에 들어있는 값들을 순서대로 확인하고 그 중 하나라도 값이 없다면, 멈춘 후 else문을 출력한다. nil 병합 연산자는 ?? 이렇게 표현하며, 옵셔널 값이 nil 일 경우 우측 값을 반환한다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 옵셔널 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 옵셔널 추출 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 옵셔널 체이닝과 nil 병합","link":"/2021/03/23/Optional/"},{"title":"iOS) Class와 Struct의 차이점에 대해 설명하시오.","text":"Class와 Struct 차이점Class 참조 타입(Reference Type) 상속 가능 heap memory 영역에 할당 (속도가 느림) 런타임에 직접 alloc하며 reference counting을 통해 dealloc이 필요 memory fragmentation 등의 overhead가 존재 NSData serialize 가능 Codable 사용 불가능 런타임에 타입 캐스팅을 통해서 클래스 인스턴스에 따라 여러 동작이 가능 deinitializer 존재 Struct / Enum 값 타입(Value Type) 상속 불가능 (protocol은 사용 가능) stack memory 영역에 할당 (속도가 빠름) scope based lifetime: 컴파일타임에 compiler가 언제 메모리를 할당/해제할지 정확히 알고있음 data locality: CPU 캐시 히트율이 높음 NSData로 serialize 불가능 Codable 프로토콜을 이용하여 손쉬운 JSON &lt;-&gt; struct 변환 가능 (Swift 4 이상) 항상 새로운 변수로 copy가 일어나기 때문에 multi-thread 환경에서 공유변수로 인해 문제를 일으킬 확률이 적음 참조 타입과 값 타입 비교참조 타입(Reference Type) 데이터를 전달할 때 값의 메모리 위치를 전달한다. 1234567891011121314151617181920212223242526272829303132333435363738// 클래스 생성class ReferenceType { var property = 1}// 클래스 인스턴스 생성// 첫 번째 참조 생성// 두 개 다 같은 것이니까 아무거나 사용하삼 ~let firstClassReference : ReferenceType = ReferenceType()// let firstClassReference = ReferenceType()// 두 번째 참조 변수에 첫 번째 참조 할당let secondClassReference = firstClassReferenceprint(&quot;first class reference property : \\(firstClassReference.property)&quot;)// ----- 출력값// 1print(&quot;second class reference property : \\(secondClassReference.property)&quot;) // ----- 출력값// 1// 두 번째 참조를 통해 인스턴스의 프로퍼티 값 변경secondClassReference.property = 2// 두 번째 클래스 참조는 첫 번째 클래스 인스턴스를 참조하기 때문에// 두 번째 참조를 통해 인스턴스의 프로퍼티 값을 변경하면// 첫 번째 클래스 인스턴스의 프로퍼티 값도 변경 됨print(&quot;first class reference property : \\(firstClassReference.property)&quot;)// ----- 출력값// 2print(&quot;second class reference property : \\(secondClassReference.property)&quot;) // ----- 출력값// 2// 상수로 선언했어도 값이 바뀌는 이유는 // secondClassReference 자체를 변경한 것이 아닌 // secondClassReference가 바라보는 값을 변경하는 것이기 때문에 가능하다. 값 타입(Value Type) 데이터를 전달할 때 값을 복사하여 전달한다. 12345678910111213141516171819202122232425// 구조체 생성struct ValueType { var property = 1}// 첫 번째 구조체 인스턴스let firstStructInstance = ValueType()// 두 번재 구조체 인스턴스에 첫 번째 인스턴스 값 복사let secondStructInstance = firstStructInstance// 두번째 구조체 인스턴스 프로퍼티 값 수정secondStructInstance.property = 2// 두 번째 구조체 인스턴스는 첫 번째 구조체를 똑같이 복사한 // 별도의 인스턴스이기 때문에 // 두 번째 구조체 인스턴스의 프로퍼티 값을 변경해도// 첫 번째 구조체 인스턴스의 프로퍼티 값에는 영향이 없음print(&quot;first struct instance property : \\(firstStructInstance.property)&quot;)// ----- 출력값// 1print(&quot;second struct instance property : \\(secondStructInstance.property)&quot;)// ----- 출력값// 2 값 타입(Value Type)을 사용하는 경우 연관된 몇몇의 값들을 모아서 하나의 데이터 타입으로 표현하고 싶은 경우 다른 객체 또는 함수 등으로 전달될 때 참조가 아니라 복사(값 복사) 할 경우 자신을 상속할 필요가 없거나, 다른 타입을 상속 받을 필요가 없는 경우 스위프트에서의 사용 스위프트의 기본 데이터 타입은 모두 구조체로 구현되어있다. 스위스트는 구조체와 열거형 사용을 선호한다. Apple 프레임워크는 대부분 클래스를 사용한다. 구조체/클래스 선택과 사용은 개발자의 몫이다. 정리 클래스는 참조 타입이고, 데이터를 전달할 때 값의 메모리 위치를 전달한다. 두 번째 클래스가 첫 번째 클래스 인스턴스를 참조하기 할 때, 두 번째 클래스의 인스턴스 프로퍼티 값을 변경하면 첫 번째 클래스 인스턴스의 프로퍼티 값도 변경된다. 구조체는 값 타입입고, 데이터를 전달할 때 값을 복사하여 전달한다. 두 번째 구조체 인스턴스가 첫 번째 구조체를 복사하면 그것은 똑같이 복사된 별도의 인스턴스이기 때문에 두 번째 구조체 인스턴스의 프로퍼티 값을 변경해도 첫 번째 구조체 인스턴스의 프로퍼티 값에는 영향이 없다. class안에 struct 변수를 property로 정의하는것 가능하며, 반대로 struct의 property중 하나로 class 인스턴스 변수를 갖고있는 것도 가능하다. 이 경우 해당 struct 변수의 copy가 일어날때 class 인스턴스의 주소값만 복사된다. 우리가 사용하는 배열, 딕셔너리, 셋과 같은 컬렉션 타입은 구조체로서 구현되어 있다. 참고 부스트코스 iOS 프로그래밍을 위한 스위프트 기초 - 클래스 vs 구조체 / 열거형 Swift struct vs. class 차이점 비교 분석","link":"/2021/09/27/Class%20vs%20Struct/"},{"title":"MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.","text":"MVC 패턴이란? Model(모델), View(뷰), Controller(컨트롤러) Traditional MVC 다이어그램을 보면 Model, View 그리고 Controller, 이 세 요소가 서로 강하게 연결되어 있음을 알 수 있다. Model에서는 애플리케이션에서 사용할 데이터들을 관리하고, View는 유저 인터페이스를 표현 및 관리한다. Controller는 View와 Model의 다리 역할을 해 View의 입력을 Model이 반영하고, Model의 변화를 View에 갱신하는 역할을 한다. 강하게 연결된 셋은 독립성이 낮기 때문에 이들 각각의 재사용성은 굉장히 떨어지며, 그렇기 때문에 현재 iOS 개발에는 전통적인 MVC 아키텍쳐는 맞지 않다고 볼 수 있다. Apple’s MVC 위의 이유로 애플에서는 새로운 MVC 아키텍쳐를 제시했다. 기존 MVC 패턴과는 다르다. Controller가 View와 Model의 중재자 역할을 함으로써 View와 Model에 독립성을 주었다. 하지만Controller의 역할을 수행하는 UIViewController의 이름에서도 알 수 있듯이,Controller가 View를 포함하는 것은 물론, View의 Life Cycle까지 관리하기 때문에 View와 Controller를 분리하기 어렵고, 재사용도 어렵다. 또한 테스트도 불가능하다.ViewController가 너무 많은 역할을 하기 때문에 MVC를 Massive View Controller라고 부르기도 한다. 그러므로 실제 다이어그램은 다음과 같은 흐름을 갖게 된다. View와 Controller가 강하게 연결되어 있어 View Controller가 거의 모든 일을 한다. Distribution - Model과 View가 독립되었지만, View와 Controller가 너무 밀접하게 연관되어있기 때문에 독립성을 확보하지 못한다.Testability - View와 Controller가 강하게 연결되어 있기 때문에, 오로지 Model만 테스팅을 진행할 수 있다.Ease of use - 다른 패턴들에 비해 코드 길이가 적고, 친숙한 아키텍처이기 때문에 개발자들이 쉽게 유지보수 할 수 있다. Cocoa MVC 패턴은 개발 진행 속도에 있어서는 가장 빠르다고 할 수 있다. 따라서 아키텍처가 중요하지 않을 때는 선택할만한 패턴이지만, 나중에 유지보수가 어렵다는 문제가 있다. 참고 iOS 아키텍처 패턴(MVC, MVVM, VIPER) protocorn93 - iOS Architecture jiyeonlab - [iOS 아키텍처 패턴] MVC iOS Architecture Patterns","link":"/2021/09/28/MVC/"}],"tags":[{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Class","slug":"Class","link":"/tags/Class/"},{"name":"Boostcourse","slug":"Boostcourse","link":"/tags/Boostcourse/"},{"name":"Struct","slug":"Struct","link":"/tags/Struct/"},{"name":"Optional","slug":"Optional","link":"/tags/Optional/"},{"name":"MVC","slug":"MVC","link":"/tags/MVC/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/tags/Design-Pattern/"},{"name":"Architecture Pattern","slug":"Architecture-Pattern","link":"/tags/Architecture-Pattern/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"}]}